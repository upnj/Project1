---
title: "ST: 558, Project1"
author: "Upendra Joshi & John Tuong"
  warning: false
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# Introduction

-   The Public Use Microdata Sample (PUMS) Census API (Application Programming Interface) is a collection of data files from the United States Census Bureau that provides access to data samples of the U.S. population and housing units. More specifically, these PUMS data sets cover the HUD's (U.S. Department of Housing and Urban Development) largest rental assistance programs (Public Housing, Section 8, etc). This data is compiled from responses to the American Community Surveys (ACS). The PUMS is comprised of two files: one for person records and the other for housing unit records. It includes geographic and household information including, but not limited to: family type, household income, race, gender, etc. The PUMS' data sets are valuable sources of information to policymakers and the researchers, as it can give some insight on how to better allocate resources and focus on helping those who need it the most.

-   By leveraging these data sets, we hope to not only grow our R skills, but to learn a little more about the world around us. For the first half, we'll be working on building functions, both helper and main functions, that will help us examine, check, process, manipulate, and build our main function to query PUMS' API. The second half of the project will build onto the first and delve into functions to that will summarize data and create visuals.

# PART I Obtaining the Data from PUMS API

-   First thing's first, with every R project, we install and load in the necessary packaaes to help create functions to do what need.

```{r}
library(tidyverse)
library(httr)
library(jsonlite)
library(dplyr)
library(tidycensus)
```

-   Next, we are going to show how URL can interact with the PUMS' API. Typically we'd start with a more bare URL when building a URL from scratch (more on that later), but I ended choosing this one because it provided a more visually appealing output as an example. After setting up the URL and making a GET, request to PUMS' API (a request sent to a server asking an API to provide a service/information), we'll take that raw data, and parse it into JSON. The initial_parse returns a tibble with the column names on the first row, so we extract those names and set them as the column names. Then we drop the first row and print a nice little tibble to get a glimpse of what information the example_url contains (take a look below!). Here we have a small tibble, 6x4, because we used the function head. These are the steps to querying APIs. So in short, we assign a URL, formulate the API request, send it, allow time to handle the response, and process the data.

```{r}
example_url <- "https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24"
initial_response <- GET(example_url)
initial_parse <- fromJSON(rawToChar(initial_response$content))
col_names <- (initial_parse[1,])
colnames(initial_parse) <- col_names
initial_parse <- initial_parse[-1,]
initial_parse <- as_tibble(initial_parse)
head(initial_parse)
```

-   To keep things simple and organized, below are all of the variables and their assigned values. Here we created vectors for each variable to reference later on.

```{r}
# Numeric variables
num_vars <- c("AGEP", "GASP", "GRPIP", "JWMNP", "PWGTP")

# Categorical variables
cat_vars <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")

# Time variables
time_vars <- c("JWAP", "JWDP")

# Geography variables
geo_vars <- c("All", "Region", "Division", "State")
```

-   Next we'll dive into all of the functions we made in order to create our main API query. The first one we have is the year_checker function. Our if statement here only allows the function to pass if the year is between 2010 to 2022 (values are inclusive). However, if the year falls outside of the range, a stop function will raise an error message and cease execution of the code.

```{r}
# Year Checker
year_checker <- function(year) {
  if (year > 2022 | year < 2010) {
    stop("Invalid year value. Please type in a number between 2010 and 2022.")
  }
}
```

-   Our second function, the num_checker, checks and coerces our assigned numeric and time variables to their respective data types. Due to the parsed JSON data, our data defaulted to a data type of character. Coercing the variables to their actual data type allows for meaning manipulation and analysis. We created a function with three parameters: initial_parse, num_vars, and time_vars. The function works by looping the column names from initial_parse. Each column name is checked to see if its name matches any from the 2 vectors, num_vars or time_vars. If the column name matches in num_vars, it will be converted to numeric through the use of as.numeric. Similarly with time_vars, it will be converted to a time format through the use of as.POSIXct. Once the function finishes looping, it will return the modified tibble/dataframe.

```{r}
# Numeric Check
num_checker <- function(initial_parse, num_vars, time_vars) {
    col_names <- colnames(initial_parse) 
      for (name in col_names) {
         if (name %in% num_vars) {
            print(name)   
            initial_parse[[name]] <- as.numeric(initial_parse[[name]])
            
         }
        if (name %in% time_vars) {
            print(name)   
            initial_parse[[name]] <- as.POSIXct(initial_parse[[name]], format = "%H:%M")
            
        }
      }
    return(initial_parse)
}

# Testing purposes/example
initial_parse <- num_checker(initial_parse, num_vars, time_vars)
```

```{r}
# Categorical variable check
cat_checker <- function(initial_parse, cat_vars) {
    col_names <- colnames(initial_parse) 
      for (name in col_names) {
         if (name %in% cat_vars) {
            print(name)   
            initial_parse[[name]] <- as.factor(initial_parse[[name]])
    }
      }
      return(initial_parse)
}

# Testing purposes/example
cat_checker(initial_parse, cat_vars)
```

```{r}
#Geography Checker
geo_checker <- function(geography_level, geo_value, geo_vars) {
  if (geography_level %in% geo_vars) {
    print("Geography level is valid.") 
  }
  else {
    print("Geography level is not valid.")
  }
}


# Testing purposes/example
geo_checker("State", "08", geo_vars)
```

```{r}
# Query the Census API
url <- "https://api.census.gov/data/"
initial_parse_final <- tibble()
census_query <- function(year, geography_level, geo_value, get, url) {
    year_list <- strsplit(year, ",")
    geo_meta <- paste0("&for=", geography_level,":",geo_value)
    if (geography_level == "All") {
      geo_meta <- ""
    }
    for (i in year_list[[1]]) {
      query_url <- paste0(url,i,"/acs/acs1/pums?","get=PWGTP,",get,geo_meta)
      initial_response <- GET(url = query_url)
      initial_parse <- fromJSON(rawToChar(initial_response$content))
      col_names <- (initial_parse[1,])
      colnames(initial_parse) <- col_names
      initial_parse <- initial_parse[-1,]
      initial_parse <- as_tibble(initial_parse)
      initial_parse_final <- bind_rows(initial_parse,initial_parse_final)
    }
    return(initial_parse_final)
}


# Testing purposes/example
initial_parse <- census_query(year = "2013", "All", "", "AGEP,SEX", url)
```

## API Function

```{r}
# Main API Query Function
main_query <- function(year = "2022", 
                       geography_level = "All", 
                       geo_value, 
                       get = "SEX,AGEP,PWGTP", 
                       url = url, 
                       num_vars = num_vars, 
                       cat_vars = cat_vars, 
                       time_vars = time_vars, 
                       geo_vars = geo_vars) {
    initial_parse <- census_query(year, geography_level, geo_value, get, url)
    initial_parse <- num_checker(initial_parse, num_vars, time_vars)
    initial_parse <- cat_checker(initial_parse, cat_vars)
    geo_checker(geography_level, geo_value, geo_vars)
    year_checker(year) 
    return(initial_parse)
} 
  

# Testing purposes/example
test <- main_query("2022", "State", "06", "SCHL", url, num_vars, cat_vars, time_vars, geo_vars)
```

```{r}

# Time Stuff
temp <- httr::GET("https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json")

#turn it into a list
temp_list <- temp$content |> rawToChar() |>jsonlite::fromJSON()
#grab just the names of JWAP and their values
JWAP <- temp_list$values$item
#reorder just so it is clearer
JWAP_values <- JWAP[sort(names(JWAP))]



```

-   For the next step, we'll be creating a function to query the PUMS' API. This query will allow for the collection and preparation of data to analyze. Our function, api_query(), contains the following parameters: year = 2022 is defaulted (it's user defined; you can only choose from years 2010 to 2022), state will populate a random number, APEG/PWGTP are defaulted, and PWGTP will always be returned.

```{r}
# NOTES/DONT USE
api_query <- function(year = 2022, #Default
                      get = "AGEP,SEX", #Default
                      state =  "07") #Default
                       {
  if (year > 2022 | year < 2010) {
    print("Invalid year value. Please type in a number between 2010 and 2022")
  }
  main_url <- paste0("https://api.census.gov/data/",year,"/acs/acs1/pums?get=PWGTP,", get,"&for=state:",state)
  response <- GET(url = main_url) 
  parsed <- fromJSON(rawToChar(response$content))
  col_names1 <- (parsed[1,])
  colnames(parsed) <- col_names1
  parsed <- parsed[-1,]
  data_as_tibble <- as_tibble(parsed)
  print(colnames(data_as_tibble))
  data_as_tibble <- data_as_tibble %>% 
    slice(-1) %>%
    mutate(AGEP = as.integer(AGEP),
          PWGTP = as.integer(PWGTP)) # If too many, use across..*
return(data_as_tibble)
}
# NOTES/DONT USE
```

# PART II Summarizing the Data and Plots

## Summary Function

-   In this section we have created 2 functions "Summary" function takes the data from tibble and generate summary statistics (mean and standard deviation) for all numeric variables and counts for all categorical variables from the data frame. This function takes three arguments - class census, numeric variables to generate summary statistics and categorical variables.

## Plot Function


