[
  {
    "objectID": "Project1.html",
    "href": "Project1.html",
    "title": "Project1",
    "section": "",
    "text": "The Public Use Microdata Sample (PUMS) Census API (Application Programming Interface) is a collection of data files from the United States Census Bureau that provides access to data samples of the U.S. population and housing units. More specifically, these PUMS data sets cover the HUD’s (U.S. Department of Housing and Urban Development) largest rental assistance programs (Public Housing, Section 8, etc). This data is compiled from responses to the American Community Surveys (ACS). The PUMS is comprised of two files: one for person records and the other for housing unit records. It includes geographic and household information including, but not limited to: family type, household income, race, gender, etc. The PUMS’ data sets are valuable sources of information to policymakers and the researchers, as it can give some insight on how to better allocate resources and focus on helping those who need it the most.\nBy leveraging these data sets, we hope to not only grow our R skills, but to learn a little more about the world around us. We’ll be focusing on creating functions to query PUMS’ Application Programming Interface (API) and process, manipulate, summarize and display data from the PUMS Census, as well as to potentially investigate interesting data points.\n\n\n#Installed and loaded in the necessary packages to help create functions and manipulate/clean data.\n#install.packages(\"tidyverse\")\n#install.packages(\"httr\") \n#install.packages(\"jsonlite\") \n#install.packages(\"dplyr\")\n#install.packages(\"tidycensus\")\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr)\nlibrary(jsonlite)\n\nWarning: package 'jsonlite' was built under R version 4.3.3\n\n\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nlibrary(dplyr)\nlibrary(tidycensus)\n\nWarning: package 'tidycensus' was built under R version 4.3.3\n\n\n\nFor the first step, we are going to build a URL in order to interact with the PUMS’ API. Building this URL will allow us to gain some insight on what all the PUMS’ data may contain. After setting up the URL and making a get rest API call (a request sent to a server asking an API to provide a service/information), we’re going to create a nice tibble to get a glimpse of what our base_url contains (take a look below!).\n\n\nurl &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?\"\nbase_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\ninitial_response &lt;- GET(url = base_url)\ninitial_parse &lt;- fromJSON(rawToChar(initial_response$content))\ncol_names &lt;- (initial_parse[1,])\ncolnames(initial_parse) &lt;- col_names\ninitial_parse &lt;- initial_parse[-1,]\ninitial_parse &lt;- as_tibble(initial_parse)\ninitial_parse\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\nbase_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\ninitial_response &lt;- GET(url = base_url)\ninitial_parse &lt;- fromJSON(rawToChar(initial_response$content))\ncol_names &lt;- (initial_parse[1,])\ncolnames(initial_parse) &lt;- col_names\ninitial_parse &lt;- initial_parse[-1,]\ninitial_parse &lt;- as_tibble(initial_parse)\ninitial_parse\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\n# Time Stuff\n\ntemp &lt;- httr::GET(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\")\n\n#turn it into a list\ntemp_list &lt;- temp$content |&gt; rawToChar() |&gt;jsonlite::fromJSON()\n#grab just the names of JWAP and their values\nJWAP &lt;- temp_list$values$item\n#reorder just so it is clearer\nJWAP_values &lt;- JWAP[sort(names(JWAP))]\n\n\n\n# Numeric variables\nnum_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")\n\n# Categorical variables\ncat_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n\n# Time variables\ntime_vars &lt;- c(\"JWAP\", \"JWDP\")\n\n# Geography variables\ngeo_vars &lt;- c(\"All\", \"Region\", \"Division\", \"State\")\n\n\n\n# Year Checker\nyear_checker &lt;- function(year) {\n  if (year &gt; 2022 | year &lt; 2010) {\n    print(\"Invalid year value. Please type in a number between 2010 and 2022\")\n  }\n}\n\n\n# Numeric Check\nnum_checker &lt;- function(initial_parse, num_vars, time_vars) {\n    col_names &lt;- colnames(initial_parse) \n      for (name in col_names) {\n         if (name %in% num_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.numeric(initial_parse[[name]])\n            \n         }\n        if (name %in% time_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.POSIXct(initial_parse[[name]], format = \"%H:%M\")\n            \n        }\n      }\n    return(initial_parse)\n}\n\n# Below is to check our work\n# initial_parse &lt;- num_checker(initial_parse, num_vars, time_vars)\n\n\n# Categorical variable check\ncat_checker &lt;- function(initial_parse, cat_vars) {\n    col_names &lt;- colnames(initial_parse) \n      for (name in col_names) {\n         if (name %in% cat_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.factor(initial_parse[[name]])\n    }\n      }\n      return(initial_parse)\n}\n\n# Below is to check our work\n# cat_checker(initial_parse, cat_vars)\n\n\n\n#Geo Checker\ngeo_checker &lt;- function(geography_level, geo_value, geo_vars) {\n  if (geography_level %in% geo_vars) {\n    print(\"Geography level is valid.\") \n  }\n  else {\n    print(\"Geography level is not valid.\")\n  }\n}\n\n\n# Below is to check our work\n# geo_checker(\"State\", \"08\", geo_vars)\n\n\n# Query the Census API\nurl &lt;- \"https://api.census.gov/data/\"\ninitial_parse_final &lt;- tibble()\ncensus_query &lt;- function(year, geography_level, geo_value, get, url) {\n    year_list &lt;- strsplit(year, \",\")\n    geo_meta &lt;- paste0(\"&for=\", geography_level,\":\",geo_value)\n    if (geography_level == \"All\") {\n      geo_meta &lt;- \"\"\n    }\n    for (i in year_list[[1]]) {\n      query_url &lt;- paste0(url,i,\"/acs/acs1/pums?\",\"get=PWGTP,\",get,geo_meta)\n      initial_response &lt;- GET(url = query_url)\n      initial_parse &lt;- fromJSON(rawToChar(initial_response$content))\n      col_names &lt;- (initial_parse[1,])\n      colnames(initial_parse) &lt;- col_names\n      initial_parse &lt;- initial_parse[-1,]\n      initial_parse &lt;- as_tibble(initial_parse)\n      initial_parse_final &lt;- bind_rows(initial_parse,initial_parse_final)\n    }\n    return(initial_parse_final)\n}\n\n# Below is to check our work\n# initial_parse &lt;- census_query(year = \"2013\", \"All\", \"\", \"AGEP,SEX\", url)\n\n\n\n# Main API Query Function\n\nmain_query &lt;- function(year = \"2022\", \n                       geography_level = \"All\", \n                       geo_value, \n                       get = \"SEX,AGEP,PWGTP\", \n                       url = url, \n                       num_vars = num_vars, \n                       cat_vars = cat_vars, \n                       time_vars = time_vars, \n                       geo_vars = geo_vars) {\n    initial_parse &lt;- census_query(year, geography_level, geo_value, get, url)\n    initial_parse &lt;- num_checker(initial_parse, num_vars, time_vars)\n    initial_parse &lt;- cat_checker(initial_parse, cat_vars)\n    geo_checker(geography_level, geo_value, geo_vars)\n    year_checker(year) \n    return(initial_parse)\n} \n  \n\n# Testing purposes/Example\ntest &lt;- main_query(\"2015\", \"State\", \"06\", \"SCHL,GASP,PWGTP\", url, num_vars, cat_vars, time_vars, geo_vars)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n[1] \"PWGTP\"\n[1] \"GASP\"\n[1] \"SCHL\"\n[1] \"Geography level is valid.\"\n\n\n\nFor the next step, we’ll be creating a function to query the PUMS’ API. This query will allow for the collection and preparation of data to analyze. Our function, api_query(), contains the following parameters: year = 2022 is defaulted (it’s user defined; you can only choose from years 2010 to 2022), state will populate a random number, APEG/PWGTP are defaulted, and PWGTP will always be returned.\n\n\n# NOTES/DONT USE\napi_query &lt;- function(year = 2022, #Default\n                      get = \"AGEP,SEX\", #Default\n                      state =  \"07\") #Default\n                       {\n  if (year &gt; 2022 | year &lt; 2010) {\n    print(\"Invalid year value. Please type in a number between 2010 and 2022\")\n  }\n  main_url &lt;- paste0(\"https://api.census.gov/data/\",year,\"/acs/acs1/pums?get=PWGTP,\", get,\"&for=state:\",state)\n  response &lt;- GET(url = main_url) \n  parsed &lt;- fromJSON(rawToChar(response$content))\n  col_names1 &lt;- (parsed[1,])\n  colnames(parsed) &lt;- col_names1\n  parsed &lt;- parsed[-1,]\n  data_as_tibble &lt;- as_tibble(parsed)\n  print(colnames(data_as_tibble))\n  data_as_tibble &lt;- data_as_tibble %&gt;% \n    slice(-1) %&gt;%\n    mutate(AGEP = as.integer(AGEP),\n          PWGTP = as.integer(PWGTP)) # If too many, use across..*\nreturn(data_as_tibble)\n}\n# NOTES/DONT USE\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this section we have created 2 functions “Summary” function takes the data from tibble and generate summary statistics (mean and standard deviation) for all numeric variables and counts for all categorical variables from the data frame. This function takes three arguments - class census, numeric variables to generate summary statistics and categorical variables.\n\n\n\n\n\ntest this"
  },
  {
    "objectID": "Project1.html#introduction",
    "href": "Project1.html#introduction",
    "title": "Project1",
    "section": "",
    "text": "The Public Use Microdata Sample (PUMS) Census API (Application Programming Interface) is a collection of data files from the United States Census Bureau that provides access to data samples of the U.S. population and housing units. More specifically, these PUMS data sets cover the HUD’s (U.S. Department of Housing and Urban Development) largest rental assistance programs (Public Housing, Section 8, etc). This data is compiled from responses to the American Community Surveys (ACS). The PUMS is comprised of two files: one for person records and the other for housing unit records. It includes geographic and household information including, but not limited to: family type, household income, race, gender, etc. The PUMS’ data sets are valuable sources of information to policymakers and the researchers, as it can give some insight on how to better allocate resources and focus on helping those who need it the most.\nBy leveraging these data sets, we hope to not only grow our R skills, but to learn a little more about the world around us. We’ll be focusing on creating functions to query PUMS’ Application Programming Interface (API) and process, manipulate, summarize and display data from the PUMS Census, as well as to potentially investigate interesting data points.\n\n\n#Installed and loaded in the necessary packages to help create functions and manipulate/clean data.\n#install.packages(\"tidyverse\")\n#install.packages(\"httr\") \n#install.packages(\"jsonlite\") \n#install.packages(\"dplyr\")\n#install.packages(\"tidycensus\")\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr)\nlibrary(jsonlite)\n\nWarning: package 'jsonlite' was built under R version 4.3.3\n\n\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nlibrary(dplyr)\nlibrary(tidycensus)\n\nWarning: package 'tidycensus' was built under R version 4.3.3\n\n\n\nFor the first step, we are going to build a URL in order to interact with the PUMS’ API. Building this URL will allow us to gain some insight on what all the PUMS’ data may contain. After setting up the URL and making a get rest API call (a request sent to a server asking an API to provide a service/information), we’re going to create a nice tibble to get a glimpse of what our base_url contains (take a look below!).\n\n\nurl &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?\"\nbase_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\ninitial_response &lt;- GET(url = base_url)\ninitial_parse &lt;- fromJSON(rawToChar(initial_response$content))\ncol_names &lt;- (initial_parse[1,])\ncolnames(initial_parse) &lt;- col_names\ninitial_parse &lt;- initial_parse[-1,]\ninitial_parse &lt;- as_tibble(initial_parse)\ninitial_parse\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\nbase_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\ninitial_response &lt;- GET(url = base_url)\ninitial_parse &lt;- fromJSON(rawToChar(initial_response$content))\ncol_names &lt;- (initial_parse[1,])\ncolnames(initial_parse) &lt;- col_names\ninitial_parse &lt;- initial_parse[-1,]\ninitial_parse &lt;- as_tibble(initial_parse)\ninitial_parse\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\n# Time Stuff\n\ntemp &lt;- httr::GET(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\")\n\n#turn it into a list\ntemp_list &lt;- temp$content |&gt; rawToChar() |&gt;jsonlite::fromJSON()\n#grab just the names of JWAP and their values\nJWAP &lt;- temp_list$values$item\n#reorder just so it is clearer\nJWAP_values &lt;- JWAP[sort(names(JWAP))]\n\n\n\n# Numeric variables\nnum_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")\n\n# Categorical variables\ncat_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n\n# Time variables\ntime_vars &lt;- c(\"JWAP\", \"JWDP\")\n\n# Geography variables\ngeo_vars &lt;- c(\"All\", \"Region\", \"Division\", \"State\")\n\n\n\n# Year Checker\nyear_checker &lt;- function(year) {\n  if (year &gt; 2022 | year &lt; 2010) {\n    print(\"Invalid year value. Please type in a number between 2010 and 2022\")\n  }\n}\n\n\n# Numeric Check\nnum_checker &lt;- function(initial_parse, num_vars, time_vars) {\n    col_names &lt;- colnames(initial_parse) \n      for (name in col_names) {\n         if (name %in% num_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.numeric(initial_parse[[name]])\n            \n         }\n        if (name %in% time_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.POSIXct(initial_parse[[name]], format = \"%H:%M\")\n            \n        }\n      }\n    return(initial_parse)\n}\n\n# Below is to check our work\n# initial_parse &lt;- num_checker(initial_parse, num_vars, time_vars)\n\n\n# Categorical variable check\ncat_checker &lt;- function(initial_parse, cat_vars) {\n    col_names &lt;- colnames(initial_parse) \n      for (name in col_names) {\n         if (name %in% cat_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.factor(initial_parse[[name]])\n    }\n      }\n      return(initial_parse)\n}\n\n# Below is to check our work\n# cat_checker(initial_parse, cat_vars)\n\n\n\n#Geo Checker\ngeo_checker &lt;- function(geography_level, geo_value, geo_vars) {\n  if (geography_level %in% geo_vars) {\n    print(\"Geography level is valid.\") \n  }\n  else {\n    print(\"Geography level is not valid.\")\n  }\n}\n\n\n# Below is to check our work\n# geo_checker(\"State\", \"08\", geo_vars)\n\n\n# Query the Census API\nurl &lt;- \"https://api.census.gov/data/\"\ninitial_parse_final &lt;- tibble()\ncensus_query &lt;- function(year, geography_level, geo_value, get, url) {\n    year_list &lt;- strsplit(year, \",\")\n    geo_meta &lt;- paste0(\"&for=\", geography_level,\":\",geo_value)\n    if (geography_level == \"All\") {\n      geo_meta &lt;- \"\"\n    }\n    for (i in year_list[[1]]) {\n      query_url &lt;- paste0(url,i,\"/acs/acs1/pums?\",\"get=PWGTP,\",get,geo_meta)\n      initial_response &lt;- GET(url = query_url)\n      initial_parse &lt;- fromJSON(rawToChar(initial_response$content))\n      col_names &lt;- (initial_parse[1,])\n      colnames(initial_parse) &lt;- col_names\n      initial_parse &lt;- initial_parse[-1,]\n      initial_parse &lt;- as_tibble(initial_parse)\n      initial_parse_final &lt;- bind_rows(initial_parse,initial_parse_final)\n    }\n    return(initial_parse_final)\n}\n\n# Below is to check our work\n# initial_parse &lt;- census_query(year = \"2013\", \"All\", \"\", \"AGEP,SEX\", url)\n\n\n\n# Main API Query Function\n\nmain_query &lt;- function(year = \"2022\", \n                       geography_level = \"All\", \n                       geo_value, \n                       get = \"SEX,AGEP,PWGTP\", \n                       url = url, \n                       num_vars = num_vars, \n                       cat_vars = cat_vars, \n                       time_vars = time_vars, \n                       geo_vars = geo_vars) {\n    initial_parse &lt;- census_query(year, geography_level, geo_value, get, url)\n    initial_parse &lt;- num_checker(initial_parse, num_vars, time_vars)\n    initial_parse &lt;- cat_checker(initial_parse, cat_vars)\n    geo_checker(geography_level, geo_value, geo_vars)\n    year_checker(year) \n    return(initial_parse)\n} \n  \n\n# Testing purposes/Example\ntest &lt;- main_query(\"2015\", \"State\", \"06\", \"SCHL,GASP,PWGTP\", url, num_vars, cat_vars, time_vars, geo_vars)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\n[1] \"PWGTP\"\n[1] \"GASP\"\n[1] \"SCHL\"\n[1] \"Geography level is valid.\"\n\n\n\nFor the next step, we’ll be creating a function to query the PUMS’ API. This query will allow for the collection and preparation of data to analyze. Our function, api_query(), contains the following parameters: year = 2022 is defaulted (it’s user defined; you can only choose from years 2010 to 2022), state will populate a random number, APEG/PWGTP are defaulted, and PWGTP will always be returned.\n\n\n# NOTES/DONT USE\napi_query &lt;- function(year = 2022, #Default\n                      get = \"AGEP,SEX\", #Default\n                      state =  \"07\") #Default\n                       {\n  if (year &gt; 2022 | year &lt; 2010) {\n    print(\"Invalid year value. Please type in a number between 2010 and 2022\")\n  }\n  main_url &lt;- paste0(\"https://api.census.gov/data/\",year,\"/acs/acs1/pums?get=PWGTP,\", get,\"&for=state:\",state)\n  response &lt;- GET(url = main_url) \n  parsed &lt;- fromJSON(rawToChar(response$content))\n  col_names1 &lt;- (parsed[1,])\n  colnames(parsed) &lt;- col_names1\n  parsed &lt;- parsed[-1,]\n  data_as_tibble &lt;- as_tibble(parsed)\n  print(colnames(data_as_tibble))\n  data_as_tibble &lt;- data_as_tibble %&gt;% \n    slice(-1) %&gt;%\n    mutate(AGEP = as.integer(AGEP),\n          PWGTP = as.integer(PWGTP)) # If too many, use across..*\nreturn(data_as_tibble)\n}\n# NOTES/DONT USE"
  },
  {
    "objectID": "Project1.html#part-ii-summarizing-the-data-and-plots",
    "href": "Project1.html#part-ii-summarizing-the-data-and-plots",
    "title": "Project1",
    "section": "",
    "text": "In this section we have created 2 functions “Summary” function takes the data from tibble and generate summary statistics (mean and standard deviation) for all numeric variables and counts for all categorical variables from the data frame. This function takes three arguments - class census, numeric variables to generate summary statistics and categorical variables.\n\n\n\n\n\ntest this"
  }
]