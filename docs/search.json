[
  {
    "objectID": "Project1.html",
    "href": "Project1.html",
    "title": "ST: 558 Project 1",
    "section": "",
    "text": "The Public Use Microdata Sample (PUMS) Census API (Application Programming Interface) is a collection of data files from the United States Census Bureau that provides access to data samples of the U.S. population and housing units. More specifically, these PUMS data sets cover the HUD’s (U.S. Department of Housing and Urban Development) largest rental assistance programs (Public Housing, Section 8, etc). This data is compiled from responses to the American Community Surveys (ACS). The PUMS is comprised of two files: one for person records and the other for housing unit records. It includes geographic and household information including, but not limited to: family type, household income, race, gender, etc. The PUMS’ data sets are valuable sources of information to policymakers and the researchers, as it can give some insight on how to better allocate resources and focus on helping those who need it the most.\nBy leveraging these data sets, we hope to not only grow our R skills, but to learn a little more about the world around us. For the first half, we’ll be working on building functions, both helper and main functions, that will help us examine, check, process, manipulate, and build our main function to query PUMS’ API. The second half of the project will build onto the first and delve into functions to that will summarize data and create visuals.\nFirst thing’s first, with every R project, we install and load in the necessary packaaes to help create functions to do what we need.\n\n\n# Loading packages\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(dplyr)\nlibrary(tidycensus)\nlibrary(lubridate)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(quantreg)\n\n\n\n\nNext, we are going to show how URL can interact with the PUMS’ API. Typically we’d start with a more bare URL when building a URL from scratch (more on that later), but I ended choosing this one because it provided a more visually appealing output as an example. After setting up the URL and making a GET, request to PUMS’ API (a request sent to a server asking an API to provide a service/information), we’ll take that raw data, and parse it into JSON. The initial_parse returns a tibble with the column names on the first row, so we extract those names and set them as the column names. Then we drop the first row and print a nice little tibble to get a glimpse of what information the example_url contains (take a look below!). Here we have a small tibble, 6x4, because we used the function head. These are the steps to querying APIs. So in short, we assign a URL, formulate the API request, send it, allow time to handle the response, and process the data.\n\n\n# Sample API call, transformed to tibble\nexample_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\ninitial_response &lt;- GET(url = example_url)\ninitial_parse &lt;- fromJSON(rawToChar(initial_response$content))\ncol_names &lt;- (initial_parse[1,])\ncolnames(initial_parse) &lt;- col_names\ninitial_parse &lt;- initial_parse[-1,]\ninitial_parse &lt;- as_tibble(initial_parse)\nhead(initial_parse)\n\n# A tibble: 6 × 4\n  SEX   PWGTP MAR   SCHL \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 2     6     5     24   \n2 2     23    2     24   \n3 1     23    3     24   \n4 1     80    5     24   \n5 1     16    1     24   \n6 1     107   3     24   \n\n\n\nTo keep things simple and organized, below are all of the variables and their assigned values. Here we created vectors for each variable to reference later on.\n\n\n# Numeric variables\nnum_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")\n\n# Categorical variables\ncat_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n\n# Time variables\ntime_vars &lt;- c(\"JWAP\", \"JWDP\")\n\n# Geography variables\ngeo_vars &lt;- c(\"All\", \"Region\", \"Division\", \"State\")\n\n# Combined variables (numeric categorical, time)\ncombined_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\", \"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\", \"JWAP\", \"JWDP\")\n\n\nNext we’ll dive into all of the functions we made in order to create our main API query. The first one we have is the year_checker function. Our if statement here only allows the function to pass if the year is between 2010 to 2022 (values are inclusive). However, if the year falls outside of the range, a stop function will raise an error message and cease execution of the code.\n\n\n# Year Checker\n# Function to check if entered year is valid\n\nyear_checker &lt;- function(year) {\n  if (year &gt; 2022 | year &lt; 2010) {\n    stop(\"Invalid year value. Please type in a number between 2010 and 2022.\")\n  }\n}\n\n\nOur second function, the num_checker, checks and coerces our assigned numeric and time variables to their respective data types. Due to the parsed JSON data, our data defaulted to a data type of character. Coercing the variables to the desired data type allows for meaning manipulation and analysis. This function contains 1 parameter and takes in 2 vectors, num_vars and time_vars, which is used to determine if the user input is of type num or time then converts it respectively to its desired data type. The function works by looping the column names from initial_parse. Each column name is checked to see if its name matches any from the 2 vectors, num_vars or time_vars. If the column name matches in num_vars, it will be converted to numeric through the use of as.numeric. Similarly with time_vars, it will be converted to a time format through the use of as.NUMERIC. Once the function finishes looping, it will return the modified tibble/dataframe.\n\n\n# Numeric Checker\n# Function to convert columns to desired numeric and time data types\n\nnum_checker &lt;- function(initial_parse) {\n    num_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")\n    time_vars &lt;- c(\"JWAP\", \"JWDP\")\n    col_names &lt;- colnames(initial_parse) \n      for (name in col_names) {\n         if (name %in% num_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.numeric(initial_parse[[name]])\n            \n         }\n     \n      }\n    return(initial_parse)\n}\n\n# Testing purposes/example\ninitial_parse &lt;- num_checker(initial_parse)\n\n[1] \"PWGTP\"\n\n\n\nCategorical checker works similarly to the numeric checker. This function contains 1 parameter and takes in 1 vector, which is used to determine if the user input is of type factor then converts it respectively to its desired data type.\n\n\n# Categorical checker\n# Function to convert columns to desired factor data types\n\n\ncat_checker &lt;- function(initial_parse) {\n    cat_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n    col_names &lt;- colnames(initial_parse) \n      for (name in col_names) {\n         if (name %in% cat_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.factor(initial_parse[[name]])\n         }  \n         if (name == \"SEX\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(SEX = recode(SEX, \"1\" = \"Male\", \"2\" = \"Female\"))\n      }\n      if (name == \"SCHL\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(SCHL = recode(SCHL, \"0\" = \"N/A (less than 3 years old)\", \"1\" = \"No schooling completed\", \"2\" = \"Nursery school, preschool\", \"3\" = \"Kindergarten\", \"4\" = \"Grade 1\", \"5\" = \"Grade 2\", \"6\" = \"Grade 3\", \"7\" = \"Grade 4\", \"8\" = \"Grade 5\", \"9\" = \"Grade 6\", \"10\" = \"Grade 7\", \"11\" = \"Grade 8\", \"12\" = \"Grade 9\", \"13\" = \"Grade 10\", \"14\" = \"Grade 11\", \"15\" = \"12th grade - no diploma\", \"16\" = \"Regular high school diploma\", \"17\" = \"GED or alternative credential\", \"18\" = \"Some college, but less than 1 year\", \"19\" = \"1 or more years of college credit, no degree\", \"20\" = \"Associate’s degree\", \"21\" = \"Bachelor’s degree\", \"22\" = \"Master’s degree\", \"23\" = \"Professional degree beyond a bachelor’s degree\", \"24\" = \"Doctorate degree\"))\n      }\n      if (name == \"HISPEED\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(HISPEED = recode(HISPEED, \"0\" = \"N/A (GQ/vacant/no paid access to the internet)\", \"1\" = \"Yes\", \"2\" = \"No\"))\n      }\n      if (name == \"HHL\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(HHL = recode(HHL, \"0\" = \"N/A (GQ/vacant\", \"1\" = \"English Only\", \"2\" = \"Spanish\", \"3\" = \"Other Indo-European languages\", \"4\" = \"Asian and Pacific Island languages\", \"5\" = \"Other languages\"))\n      }\n      if (name == \"FER\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(FER = recode(FER, \"0\" = \"N/A (less than 15 years/greater than 50 years/ male)\", \"1\" = \"Yes\", \"2\" = \"No\"))\n      }\n  \n\n    }\n\n      return(initial_parse)\n}\n\n# Testing purposes/example\ninitial_parse &lt;- cat_checker(initial_parse)\n\n[1] \"SEX\"\n[1] \"SCHL\"\n\n\n\nNext we have the geography checker. This function has 1 parameter and takes in 1 vector. If the provided geography_level is in the geo_vars vector, it will print that the geography level is valid. If not then it will print is not valid.\n\n\n# Geography Checker\n# Function to specify and  check if geography level is correct\n\ngeo_checker &lt;- function(geography_level, geography_subset) {\n  geo_vars &lt;- c(\"All\", \"Region\", \"Division\", \"State\")\n  if (geography_level %in% geo_vars) {\n    print(\"Geography level is valid.\") \n  }\n  else {\n    print(\"Geography level is not valid.\")\n  }\n}\n\n# Testing purposes/example\ngeo_checker(\"State\", \"08\")\n\n[1] \"Geography level is valid.\"\n\n\n\nHere we have a function to query the census. This function contains 4 parameters. First, an empty tibble is initialized in order to store the results; this is important as it holds the multiple tibbles to later bind together. We assign a variable named year_list to take on the function string split for parameter, year, because we want to allow the user to be able to specify multiple years of survey data. String split works here because when inputting multiple years, “2012,2013,2015”, the user needs to input the years all as one string, then strsplit will work to split the different years into a list of year to call each year separately. The for loop at the bottom, (i in year_list[[1]]), loops over the list of years from the user into the query_url, allowing them to make API requests for each given year.\nNext, there are some words that we hard coded into the URL because we needed to return those columns, we chose: “PWGTP”, “GASP”, and “FER”. However, if the user doesn’t know, they could input one of these columns again, producing a duplicate column. To fix this, we have to use grepl, to search for a string within a string then we use gsub to remove the said string. The second gsub is a catch all, removing commas from before/after the string due to user input. This way, even if the user inputs those columns, it would no longer create a duplicate. Then we create an if statement where it does not allow the user to input a geography_subset if they choose “All” by creating a variable named geo_meta and add it onto our query_url below. So to briefly go over our first example, bottom portion of the code is using the given query_url, we send a GET request to formulate the API request, allow time to handle the response, process the data, extract column nam, apply them accordingly, then create tibbles. As mentioned earlier, if user inputs multiple years then the for loop won’t end until the last inputted year, then the bind_rows function will combine all of the tibbles from each year of the user input together.\n\n\n# Function to Query the Census API \n# Created if statements using grepl/gsub to remove duplicate columns\n# Allow users to call multiple years then combining tibbles as the end using bind_rowss\n# Used helper GET here then turned into tibble\n\ncensus_query &lt;- function(year, geography_level, geography_subset, get) {\n    initial_parse_final &lt;- tibble()\n    year_list &lt;- strsplit(year, \",\")\n    url &lt;- \"https://api.census.gov/data/\"\n    if (grepl(\"PWGTP\", get)) {\n      get &lt;- gsub(\"PWGTP|PWGTP,\",'',get)\n      get &lt;- gsub(\"^\\\\,|\\\\,$\",'',get) \n    }\n    if (grepl(\"GASP\", get)) {\n      get &lt;- gsub(\"GASP|GASP,\",'',get)\n      get &lt;- gsub(\"^\\\\,|\\\\,$\",'',get)\n    }\n    if (grepl(\"FER\", get)) {\n      get &lt;- gsub(\"FER|FER,\",'',get)\n      get &lt;- gsub(\"^\\\\,|\\\\,$\",'',get)\n    }\n    geo_meta &lt;- paste0(\"&for=\", geography_level,\":\",geography_subset)\n    if (geography_level == \"All\") {\n      geo_meta &lt;- \"\"\n    }\n    for (i in year_list[[1]]) {\n      query_url &lt;- paste0(url,i,\"/acs/acs1/pums?\",\"get=PWGTP,GASP,FER,\",get,geo_meta)\n      initial_response &lt;- GET(url = query_url)\n      initial_parse &lt;- fromJSON(rawToChar(initial_response$content))\n      col_names &lt;- (initial_parse[1,])\n      colnames(initial_parse) &lt;- col_names\n      initial_parse &lt;- initial_parse[-1,]\n      initial_parse &lt;- as_tibble(initial_parse)\n      initial_parse_final &lt;- bind_rows(initial_parse,initial_parse_final)\n    }\n    return(initial_parse_final)\n}\n\n# Testing purposes/example\ninitial_parse &lt;- census_query(year = \"2011,2014\", \"State\", \"08\", \"AGEP,SEX\")\n\n\nNow we can create our final/main API query. This API query contains 4 parameters (year = “2022”, geography_level = “All”, geography_subset and get = “SEX,AGEP,PWGTP”, with their respective defaults) and takes in vector combined_vars. We create a strsplit for the get results, similarly to what we did for the years in the census_query results. When a user inputs variables, it will check and ensure those column names are valid. If they are then it will print, “Column X entered is valid” and if not then it will tell the user to try again. After that, initial_parse is reassigned and overwritten once it goes through each function (census_query, num_checker, time_checker, cat_checker) and checker (geo_checker, year_checker). Then it will return a final tibble at the end.\n\n\n\n\n# Main API Query Function (combined all of the previous functions)\n# Added SEX, AGEP, PWGTP in the get of the main_query to be returned as default\n# Added combined_vars and for loop to validate and check that user inputted columns are valid\n\nmain_query &lt;- function(year = \"2022\", \n                       geography_level = \"All\", \n                       geography_subset,  \n                       get = \"SEX,AGEP,PWGTP\") { \n    combined_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\", \"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\", \"JWAP\", \"JWDP\")\n    get_list &lt;- strsplit(get, \",\")\n    for (i in get_list[[1]]) {\n      if (i %in% combined_vars) {\n        cat(\"Column (\",i ,\") entered is valid.\")\n      }\n      else (\n        stop(\"Column (\",i,\") entered is not valid. Try again\")\n            )\n    }\n    initial_parse &lt;- census_query(year, geography_level, geography_subset, get)\n    initial_parse &lt;- num_checker(initial_parse)\n    initial_parse &lt;- cat_checker(initial_parse)\n    geo_checker(geography_level, geography_subset)\n    year_checker(year) \n    \n    # This is for the summary function in Part 2\n    class(initial_parse) &lt;-c(\"census\", class(initial_parse))\n    return(initial_parse)\n} \n\n# Testing purposes/example\ntest &lt;- main_query(\"2018,2015\", \"State\", \"08\", \"FER,JWAP,SEX,SCHL,GASP\")\n\nColumn ( FER ) entered is valid.Column ( JWAP ) entered is valid.Column ( SEX ) entered is valid.Column ( SCHL ) entered is valid.Column ( GASP ) entered is valid.[1] \"PWGTP\"\n[1] \"GASP\"\n[1] \"FER\"\n[1] \"SEX\"\n[1] \"SCHL\"\n[1] \"Geography level is valid.\"\n\n# All variable query\neverything &lt;- main_query(\"2022\", \"State\", \"08\", \"AGEP,GASP,GRPIP,JWMNP,PWGTP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX,JWAP,JWDP\")\n\nColumn ( AGEP ) entered is valid.Column ( GASP ) entered is valid.Column ( GRPIP ) entered is valid.Column ( JWMNP ) entered is valid.Column ( PWGTP ) entered is valid.Column ( FER ) entered is valid.Column ( HHL ) entered is valid.Column ( HISPEED ) entered is valid.Column ( JWTRNS ) entered is valid.Column ( SCH ) entered is valid.Column ( SCHL ) entered is valid.Column ( SEX ) entered is valid.Column ( JWAP ) entered is valid.Column ( JWDP ) entered is valid.[1] \"PWGTP\"\n[1] \"GASP\"\n[1] \"AGEP\"\n[1] \"GRPIP\"\n[1] \"JWMNP\"\n[1] \"FER\"\n[1] \"HHL\"\n[1] \"HISPEED\"\n[1] \"JWTRNS\"\n[1] \"SCH\"\n[1] \"SCHL\"\n[1] \"SEX\"\n[1] \"Geography level is valid.\"\n\nprint(everything)\n\n# A tibble: 59,841 × 15\n   PWGTP  GASP FER       AGEP GRPIP JWMNP HHL   HISPEED JWTRNS SCH   SCHL  SEX  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt;   &lt;fct&gt;  &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;\n 1    70     3 No          18     0     0 N/A … N/A (G… 11     2     Some… Fema…\n 2    41     3 N/A (le…    35     0     0 N/A … N/A (G… 0      1     Grad… Male \n 3    35     3 N/A (le…    40     0     0 N/A … N/A (G… 0      1     Grad… Male \n 4    30     3 No          20     0     0 N/A … N/A (G… 0      2     1 or… Fema…\n 5     4     3 N/A (le…    14     0     0 N/A … N/A (G… 0      2     Grad… Male \n 6    75     3 No          28     0     0 N/A … N/A (G… 0      1     Regu… Fema…\n 7    22     3 N/A (le…    47     0     0 N/A … N/A (G… 0      1     Regu… Male \n 8    36     3 N/A (le…    28     0     0 N/A … N/A (G… 0      1     Regu… Male \n 9    59     3 N/A (le…    77     0     0 N/A … N/A (G… 0      1     Regu… Fema…\n10    11     3 N/A (le…    20     0     2 N/A … N/A (G… 10     1     Some… Male \n# ℹ 59,831 more rows\n# ℹ 3 more variables: JWAP &lt;chr&gt;, JWDP &lt;chr&gt;, state &lt;chr&gt;\n\n\n\nThe API function, main_query, interacts, retrieves, and processes raw data from the U.S. Census API, and allows us to query, structure, and validate data, into a tibble based on user input. With that, we will move onto creating the summary and plot functions, hoping to research and analyze some interesting data that we extract from the API function.\n\n\n\n\n\n\n\n\nIn this section we have created 2 functions “Summary” function takes the data from tibble and generate summary statistics (mean and standard deviation) for all numeric variables and counts for all categorical variables from the data frame. This function takes three arguments - class census, numeric variables to generate summary statistics and categorical variables. The second function is a plot function, where we generate the box plot.\n\n\nsummary.census &lt;- function(object, numeric_vars = NULL, categorical_vars = NULL) {\n  \n  #convert JWAP and JWDP into numeric variables\n  object$JWAP &lt;- as.numeric(object$JWAP)\n  object$JWDP &lt;- as.numeric(object$JWDP)\n  \n  # If no variables specified, get all appropriate variables\n  if (is.null(numeric_vars)) {\n    numeric_vars &lt;- c(names(object)[sapply(object, is.numeric)], \"JWAP\", \"JWDP\")\n    numeric_vars &lt;- setdiff(numeric_vars, \"PWGTP\")  # Exclude weight variable\n  }\n  \n  if (is.null(categorical_vars)) {\n    categorical_vars &lt;- names(object)[sapply(object, function(x) \n      is.character(x) || is.factor(x))]\n  }\n  \n  # Ensure JWAP and JWDP are in numeric_vars and not in categorical_vars\n  numeric_vars &lt;- union(numeric_vars, c(\"JWAP\", \"JWDP\"))\n  categorical_vars &lt;- setdiff(categorical_vars, c(\"JWAP\", \"JWDP\"))\n  \n  # Initialize results list\n  results &lt;- list()\n  \n  # Define labels for all variables\n  variable_labels &lt;- list(\n    AGEP = \"Age\",\n    JWMNP = \"Travel time to work\",\n    GRPIP = \"Gross rent as a percentage of household income\",\n    GASP = \"Gasoline cost (monthly)\",\n    FER = \"Gave birth to child within the past 12 months\",\n    SEX = \"Sex\",\n    SCH = \"School enrollment\",\n    SCHL = \"Educational attainment\",\n    HHL = \"Household language\",\n    HISPEED = \"High speed internet\",\n    JWTRNS = \"Means of transportation to work\",\n    JWAP = \"Time of arrival at work\",\n    JWDP = \"Time of departure for work\"\n  )\n  \n  # Calculate weighted means and standard deviations for numeric variables\n  if (length(numeric_vars) &gt; 0) {\n    numeric_summary &lt;- list()\n    \n    for (var in numeric_vars) {\n      # Get the variable and weights\n      x &lt;- object[[var]]\n      w &lt;- object[[\"PWGTP\"]]\n      \n      # Remove NA and infinite values\n      valid &lt;- !is.na(x) & !is.infinite(x) & !is.na(w) & !is.infinite(w)\n      x &lt;- x[valid]\n      w &lt;- w[valid]\n      \n      # Calculate weighted mean\n      weighted_mean &lt;- sum(x * w) / sum(w)\n      \n      # Calculate weighted standard deviation\n      weighted_sd &lt;- sqrt(sum(x^2 * w) / sum(w) - weighted_mean^2)\n      \n      # Get label for the variable\n      label &lt;- if (var %in% names(variable_labels)) variable_labels[[var]] else var\n      \n      # Store results\n      numeric_summary[[label]] &lt;- list(\n        mean = weighted_mean,\n        sd = weighted_sd\n      )\n    }\n    \n    results[[\"numeric_summary\"]] &lt;- numeric_summary\n  }\n  \n  # Calculate counts for categorical variables\n  if (length(categorical_vars) &gt; 0) {\n    categorical_summary &lt;- list()\n    \n    # Define mappings for categorical variables\n    category_mappings &lt;- list(\n      FER = c(\"0\" = \"N/A\", \"1\" = \"Yes\", \"2\" = \"No\"),\n      SEX = c(\"1\" = \"Male\", \"2\" = \"Female\"),\n      SCHL = c(\"1\" = \"No schooling completed\",\n               \"2\" = \"Nursery school, preschool\",\n               \"3\" = \"Kindergarten\",\n               \"4\" = \"Grade 1\",\n               \"5\" = \"Grade 2\",\n               \"6\" = \"Grade 3\",\n               \"7\" = \"Grade 4\",\n               \"8\" = \"Grade 5\",\n               \"9\" = \"Grade 6\",\n               \"10\" = \"Grade 7\",\n               \"11\" = \"Grade 8\",\n               \"12\" = \"Grade 9\",\n               \"13\" = \"Grade 10\",\n               \"14\" = \"Grade 11\",\n               \"15\" = \"12th grade - no diploma\",\n               \"16\" = \"Regular high school diploma\",\n               \"17\" = \"GED or alternative credential\",\n               \"18\" = \"Some college, but less than 1 year\",\n               \"19\" = \"1 or more years of college credit, no degree\",\n               \"20\" = \"Associate's degree\",\n               \"21\" = \"Bachelor's degree\",\n               \"22\" = \"Master's degree\",\n               \"23\" = \"Professional degree beyond a bachelor's degree\",\n               \"24\" = \"Doctorate degree\"),\n      HHL = c(\"0\" = \"N/A (GQ/vacant)\",\n              \"1\" = \"English Only\",\n              \"2\" = \"Spanish\",\n              \"3\" = \"Other Indo-European languages\",\n              \"4\" = \"Asian and Pacific Island languages\",\n              \"5\" = \"Other Language\"),\n      HISPEED = c(\"0\" = \"N/A (GQ/vacant/no paid access to the internet)\",\n                  \"1\" =  \"Yes\",\n                  \"2\" = \"No\"),\n      \n      SCH = c(\"0\" = \"N/A (less than 3 years old)\",\n              \"1\" = \"No, has not attended in the last 3 months\",\n              \"2\" = \"Yes, public school or public college\",\n              \"3\" = \"Yes, private school or college or home school\"))\n      \n    \n    for (var in categorical_vars) {\n      # Get counts\n      counts &lt;- table(object[[var]])\n      \n      # Apply mapping if available\n      \n       # Special handling for SEX variable\n      if (var == \"SEX\") {\n        counts_to_use &lt;- counts\n        names(counts_to_use) &lt;- levels(object[[var]])  # Preserve original labels\n      }else   if (var == \"JWTRNS\") {\n      # Special handling for JWTRNS\n      jwtrns_mapping &lt;- c(\n        \"0\" = \"N/A\",\n        \"1\" = \"Car, truck, or van\",\n        \"2\" = \"Bus\",\n        \"3\" = \"Subway or elevated rail\",\n        \"4\" = \"Long-distance train or commuter rail\",\n        \"5\" = \"Light rail, streetcar, or trolley\",\n        \"6\" = \"Ferryboat\",\n        \"7\" = \"Taxicab\",\n        \"8\" = \"Motorcycle\",\n        \"9\" = \"Bicycle\",\n        \"10\" = \"Walked\",\n        \"11\" = \"Worked from home\",\n        \"12\" = \"Other method\"\n      )\n      counts_to_use &lt;- counts\n      names(counts_to_use) &lt;- jwtrns_mapping[names(counts)]\n      } else if (var %in% names(category_mappings)) {\n        mapped_counts &lt;- counts\n        names(mapped_counts) &lt;- category_mappings[[var]][names(counts)]\n        counts_to_use &lt;- mapped_counts\n      } else {\n        counts_to_use &lt;- counts\n      }\n      \n      # Get label for the variable\n      label &lt;- if (var %in% names(variable_labels)) variable_labels[[var]] else var\n      \n      # Store results with label\n      categorical_summary[[label]] &lt;- counts_to_use\n    }\n    \n    results[[\"categorical_summary\"]] &lt;- categorical_summary\n  }\n  \n  return(results)\n}\n\nNow Let’s test our summary function. This will give us the weighted means and standard deviations for numeric variables and counts for categorical variables\n\n# Using default behavior (all variables)\nresults1 &lt;- summary.census(everything)\nprint(results1)\n\n$numeric_summary\n$numeric_summary$`Gasoline cost (monthly)`\n$numeric_summary$`Gasoline cost (monthly)`$mean\n[1] 65.96931\n\n$numeric_summary$`Gasoline cost (monthly)`$sd\n[1] 145.7646\n\n\n$numeric_summary$Age\n$numeric_summary$Age$mean\n[1] 38.80219\n\n$numeric_summary$Age$sd\n[1] 22.42793\n\n\n$numeric_summary$`Gross rent as a percentage of household income`\n$numeric_summary$`Gross rent as a percentage of household income`$mean\n[1] 10.71139\n\n$numeric_summary$`Gross rent as a percentage of household income`$sd\n[1] 22.36287\n\n\n$numeric_summary$`Travel time to work`\n$numeric_summary$`Travel time to work`$mean\n[1] 10.6618\n\n$numeric_summary$`Travel time to work`$sd\n[1] 18.26052\n\n\n$numeric_summary$`Time of arrival at work`\n$numeric_summary$`Time of arrival at work`$mean\n[1] 42.47839\n\n$numeric_summary$`Time of arrival at work`$sd\n[1] 55.53998\n\n\n$numeric_summary$`Time of departure for work`\n$numeric_summary$`Time of departure for work`$mean\n[1] 22.43893\n\n$numeric_summary$`Time of departure for work`$sd\n[1] 31.50714\n\n\n\n$categorical_summary\n$categorical_summary$`Gave birth to child within the past 12 months`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n46345   655 12841 \n\n$categorical_summary$`Household language`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 2790 46143  6558  2226  1591   533 \n\n$categorical_summary$`High speed internet`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 5405 47042  7394 \n\n$categorical_summary$`Means of transportation to work`\n                                 N/A                   Car, truck, or van \n                               29658                                21488 \n                              Walked                     Worked from home \n                                 816                                 6791 \n                        Other method                                  Bus \n                                 272                                  279 \n             Subway or elevated rail Long-distance train or commuter rail \n                                  13                                   15 \n   Light rail, streetcar, or trolley                            Ferryboat \n                                 104                                    6 \n                             Taxicab                           Motorcycle \n                                  17                                   50 \n                             Bicycle \n                                 332 \n\n$categorical_summary$`School enrollment`\n                  N/A (less than 3 years old) \n                                         1592 \n    No, has not attended in the last 3 months \n                                        45041 \n         Yes, public school or public college \n                                        11146 \nYes, private school or college or home school \n                                         2062 \n\n$categorical_summary$`Educational attainment`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 1592  1502   777   941   952  1111  1342   790  8407  1842  3275  6427   773 \n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 3761 13278  5970  1284  1031   665   576   648   682   710   717   788 \n\n$categorical_summary$Sex\n  Male Female \n 29940  29901 \n\n$categorical_summary$state\n\n   08 \n59841 \n\n\nWe can use specific variables and check if we can generate the summary for examples we can select few numeric variables and few categorical variables as follows\n\n# Specifying specific variables\nresults &lt;- summary.census(everything, \n                  numeric_vars = c(\"AGEP\", \"GRPIP\"),\n                  categorical_vars = c(\"SEX\", \"FER\"))\n\nprint(results)\n\n$numeric_summary\n$numeric_summary$Age\n$numeric_summary$Age$mean\n[1] 38.80219\n\n$numeric_summary$Age$sd\n[1] 22.42793\n\n\n$numeric_summary$`Gross rent as a percentage of household income`\n$numeric_summary$`Gross rent as a percentage of household income`$mean\n[1] 10.71139\n\n$numeric_summary$`Gross rent as a percentage of household income`$sd\n[1] 22.36287\n\n\n$numeric_summary$`Time of arrival at work`\n$numeric_summary$`Time of arrival at work`$mean\n[1] 42.47839\n\n$numeric_summary$`Time of arrival at work`$sd\n[1] 55.53998\n\n\n$numeric_summary$`Time of departure for work`\n$numeric_summary$`Time of departure for work`$mean\n[1] 22.43893\n\n$numeric_summary$`Time of departure for work`$sd\n[1] 31.50714\n\n\n\n$categorical_summary\n$categorical_summary$Sex\n  Male Female \n 29940  29901 \n\n$categorical_summary$`Gave birth to child within the past 12 months`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n46345   655 12841 \n\n\n\n\n\n\nplot.census &lt;- function(x, cat_var, num_var, \n                        title = NULL, \n                        x_label = NULL, \n                        y_label = NULL, \n                        fill_colors = c(\"#1f77b4\", \"#ff7f0e\"),\n                        ...) {\n  # Check if the object is of class \"census\"\n  if (!inherits(x, \"census\")) {\n    stop(\"This function only works for objects of class 'census'\")\n  }\n  \n  # Check if cat_var and num_var are provided\n  if (missing(cat_var) || missing(num_var)) {\n    stop(\"Both cat_var and num_var must be specified\")\n  }\n  \n  # Check if cat_var and num_var exist in the data\n  if (!cat_var %in% names(x)) {\n    stop(paste(\"Categorical variable\", cat_var, \"not found in the data\"))\n  }\n  if (!num_var %in% names(x)) {\n    stop(paste(\"Numeric variable\", num_var, \"not found in the data\"))\n  }\n  \n  # Check if cat_var is categorical (factor or character)\n  if (!is.factor(x[[cat_var]]) && !is.character(x[[cat_var]])) {\n    stop(paste(cat_var, \"must be a categorical variable (factor or character)\"))\n  }\n  \n  # Check if num_var is numeric\n  if (!is.numeric(x[[num_var]])) {\n    stop(paste(num_var, \"must be a numeric variable\"))\n  }\n  \n  # Set default labels if not provided\n  if (is.null(title)) {\n    title &lt;- paste(\"Weighted Boxplot of\", num_var, \"by\", cat_var)\n  }\n  if (is.null(x_label)) {\n    x_label &lt;- cat_var\n  }\n  if (is.null(y_label)) {\n    y_label &lt;- num_var\n  }\n  \n  # Create the plot\n  p &lt;- ggplot(x, aes(x = .data[[cat_var]], y = .data[[num_var]], weight = PWGTP, fill = .data[[cat_var]])) +\n    geom_boxplot() +\n    labs(title = title, x = x_label, y = y_label) +\n    scale_fill_manual(values = fill_colors) +\n    theme_minimal() +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1),\n          legend.position = \"none\")  # Remove legend as it's redundant with x-axis labels\n  \n  # Print the plot\n  print(p)\n  \n  # Return the plot object invisibly\n  invisible(p)\n}\n\nLet’s test the plot function\n\n# Age distribution by sex\n\nplot.census(everything, \n            cat_var = \"SEX\", \n            num_var = \"AGEP\",\n            title = \"Age Distribution by Sex\",\n            x_label = \"Sex\",\n            y_label = \"Age\",\n            fill_colors = c(\"#FFA07A\", \"#20B2AA\"))\n\n\n\n\n\n\n\n# Travel time to work by sex\nplot.census(everything, \n            cat_var = \"SEX\", \n            num_var = \"JWMNP\",\n            title = \"Travel Time to Work by Sex\",\n            x_label = \"Sex\",\n            y_label = \"Travel Time (minutes)\",\n            fill_colors = c(\"#4E79A7\", \"#F28E2B\"))\n\n\n\n\n\n\n\n#Gross rent as percentage of income by household language\n\n# Create a color palette for the number of language categories\nnum_languages &lt;- length(unique(everything$HHL))\ncolor_palette &lt;- colorRampPalette(c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"))(num_languages)\n\n# Create the plot\nrent_language_plot &lt;- plot.census(everything, \n                                  cat_var = \"HHL\", \n                                  num_var = \"GRPIP\",\n                                  title = \"Gross Rent as Percentage of Household Income by Household    \n                                           Language\",\n                                  x_label = \"Household Language\",\n                                  y_label = \"Gross Rent as Percentage of Income\",\n                                  fill_colors = color_palette)\n\n\n\n\n\n\n\n\n\n\n\n\nNow we are all set! We can extract the data using main_query function and summaries it by summary.census function also we can create box plots using the plot function. Let’s understand the relationship between different variables and interpret the data using our summary and plot functions.\nFor example we would like to get the answers of following questions #### What is the overall age and gender distribution of the population?\n\n# Get summary statistics\nsummary_stats &lt;- summary.census(everything)\nprint(summary_stats$numeric_summary$Age)\n\n$mean\n[1] 38.80219\n\n$sd\n[1] 22.42793\n\nprint(summary_stats$categorical_summary$Sex)\n\n  Male Female \n 29940  29901 \n\n# Create an age distribution plot by gender\nage_gender_plot &lt;- plot.census(everything, \n                               cat_var = \"SEX\", \n                               num_var = \"AGEP\",\n                               title = \"Age Distribution by Gender\",\n                               x_label = \"Gender\",\n                               y_label = \"Age\",\n                               fill_colors = c(\"#FF9999\", \"#66B2FF\"))\n\n\n\n\n\n\n\n\nThe summary statistics for age show:\nMean age: 38.80 years Standard deviation: 22.43 years\nThis indicates that:\nThe average age of the population is about 39 years old. There’s a considerable spread in ages, with a standard deviation of about 22 years. This suggests a diverse population with a mix of younger and older individuals.\nGender Distribution Male = 29,940 (50.03%) Female = 29,901 (49.97%)\nWhich shows not much a difference in gender distribution\n\n\n\n# Create a plot of educational attainment by age, colored by gender\n\nggplot(everything, aes(x = SCHL, y = AGEP, fill = SEX)) +\n  geom_boxplot() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  labs(x = \"Educational Attainment\", y = \"Age\", fill = \"Sex\")\n\n\n\n\n\n\n\n# Create a contingency table of education by gender\ntable(everything$SCHL, everything$SEX)\n\n                                                \n                                                 Male Female\n  N/A (less than 3 years old)                     830    762\n  No schooling completed                          730    772\n  Grade 7                                         414    363\n  Grade 8                                         483    458\n  Grade 9                                         504    448\n  Grade 10                                        587    524\n  Grade 11                                        763    579\n  12th grade - no diploma                         444    346\n  Regular high school diploma                    4335   4072\n  GED or alternative credential                  1118    724\n  Some college, but less than 1 year             1585   1690\n  1 or more years of college credit, no degree   3288   3139\n  Nursery school, preschool                       392    381\n  Associate’s degree                             1729   2032\n  Bachelor’s degree                              6345   6933\n  Master’s degree                                2679   3291\n  Professional degree beyond a bachelor’s degree  696    588\n  Doctorate degree                                558    473\n  Kindergarten                                    353    312\n  Grade 1                                         311    265\n  Grade 2                                         304    344\n  Grade 3                                         354    328\n  Grade 4                                         347    363\n  Grade 5                                         411    306\n  Grade 6                                         380    408\n\n\nThis analysis gives us a detailed picture of educational attainment patterns across age groups and genders in your population. It highlights the progress made in educational equality, particularly in higher education, while also pointing out areas where disparities still exist.\nFrom the contingency table we can compare the two groups (Male vs Female) The most common education level for both genders is “21” (Bachelor’s degree), followed by “16” (Regular high school diploma). Women tend to outnumber men in Associate’s degrees (20) and Bachelor’s degrees (21). Men slightly outnumber women in Professional degrees beyond a bachelor’s degree (23).\nFrom the box plot we observe following things\nThere’s a wide range of ages for most education levels, indicating lifelong learning or varied educational paths. The median age generally increases with higher levels of educational attainment. Lower education levels (0-9) show a wide age range, possibly indicating both young individuals still in school and older individuals with limited formal education. Higher education levels (16-24) show higher median ages, as expected. There’s a noticeable jump in median age for doctorate degrees (24), with females having a slightly higher median age than males.\n\n\n\n\n# Get summary of transportation methods\nsummary_stats &lt;- summary.census(everything)\nprint(summary_stats$categorical_summary$`Means of transportation to work`)\n\n                                 N/A                   Car, truck, or van \n                               29658                                21488 \n                              Walked                     Worked from home \n                                 816                                 6791 \n                        Other method                                  Bus \n                                 272                                  279 \n             Subway or elevated rail Long-distance train or commuter rail \n                                  13                                   15 \n   Light rail, streetcar, or trolley                            Ferryboat \n                                 104                                    6 \n                             Taxicab                           Motorcycle \n                                  17                                   50 \n                             Bicycle \n                                 332 \n\n# Create a plot of commute times by transportation method\nplot.census(everything, \n                            cat_var = \"JWTRNS\", \n                            num_var = \"JWMNP\",\n                            title = \"Commute Times by Transportation Method\",\n                            x_label = \"Transportation Method\",\n                            y_label = \"Commute Time (minutes)\",\n                            fill_colors = colorRampPalette(c(\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\", \"#ffd92f\"))(length(levels(everything$JWTRNS))))\n\n\n\n\n\n\n\n\nThis analysis gives us a clear picture of the transportation landscape in your population. The dominance of personal vehicles, the significant proportion of remote workers, and the relatively low usage of public transit are key findings that have important implications for urban planning, environmental policies, and quality of life in the area.\nNon-commuters or Unspecified: The largest category is “N/A” (49.6%), which likely includes non-workers, remote workers, or those with unspecified commute methods.\nVehicle Dominance: Among those who commute, personal vehicles (car, truck, or van) are overwhelmingly the most common method, used by 36.0% of the total population and 70.9% of specified commuters. Remote Work Trend: A significant portion (11.4%) work from home, reflecting modern work trends and potentially impacting traditional commute patterns.\nActive Transportation: Walking (1.4%) and cycling (0.6%) combined account for 2% of commuters, representing a small but notable group using active transportation.\nPublic Transit: All forms of public transit (bus, light rail, subway, train) combined account for only about 0.7% of commuters, suggesting limited public transit infrastructure or usage.\nAlternative Methods: Motorcycles, taxicabs, and ferryboats are used by a very small fraction of commuters, likely reflecting niche transportation needs or preferences.\n\n\n\n\n# Create a plot of rent burden by household language\n\nplot.census(everything, \n                                  cat_var = \"HHL\", \n                                  num_var = \"GRPIP\",\n                                  title = \"Rent Burden by Household Language\",\n                                  x_label = \"Household Language\",\n                                  y_label = \"Gross Rent as Percentage of Household Income\",\n                                  fill_colors = colorRampPalette(c(\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\"))(length(levels(everything$HHL))))\n\n\n\n\n\n\n\n\nThis analysis provides insights into the relationship between household language and rent burden, addressing the question about the connection between household language and economic indicators. The data suggests that there are indeed significant differences in economic stress related to housing costs across different language groups.\n1. Language Disparities: There’s a clear disparity in rent burden across language groups, with English-only households generally facing lower rent burdens.\n2. Vulnerable Groups: Spanish-speaking households and those speaking “Other Languages” appear to face the highest rent burdens, suggesting greater economic vulnerability.\n3.Variability Within Groups: All language groups show significant variability in rent burden, indicating that factors beyond language (such as income, location, or occupation) play important roles.\n4. Outlines: All groups have outliers with extremely high rent burdens (over 75% of income), but these are more prevalent in non-English speaking households.\n5. Economic Integration: The overlap in distributions suggests that while there are trends, language alone doesn’t determine economic status or rent burden.\n\n\n\n\n# Reclassify transportation categories\neverything$transport_category &lt;- case_when(\n  everything$JWTRNS == \"1\" ~ \"Car\",\n  everything$JWTRNS %in% c(\"2\", \"3\", \"4\", \"5\", \"7\") ~ \"Public Transport\",\n  TRUE ~ \"Other\"\n)\n\n# Filter for car and public transport users with non-zero GRPIP\ntransport_rent_data &lt;- everything[everything$transport_category %in% c(\"Car\", \"Public Transport\") & everything$GRPIP &gt; 0, ]\n\n# Ensure transport_category is a factor\ntransport_rent_data$transport_category &lt;- factor(transport_rent_data$transport_category)\n\n# Summary statistics\ncar_summary &lt;- summary(transport_rent_data$GRPIP[transport_rent_data$transport_category == \"Car\"])\npt_summary &lt;- summary(transport_rent_data$GRPIP[transport_rent_data$transport_category == \"Public Transport\"])\n\nprint(\"Summary for Car Users:\")\n\n[1] \"Summary for Car Users:\"\n\nprint(car_summary)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    1.0    18.0    26.0    32.9    39.0   101.0 \n\nprint(\"Summary for Public Transport Users:\")\n\n[1] \"Summary for Public Transport Users:\"\n\nprint(pt_summary)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00   21.00   31.00   39.08   50.00  101.00 \n\n# Visualization: Boxplot\n\nplot.census(transport_rent_data, \n            cat_var = \"transport_category\", \n            num_var = \"GRPIP\",\n            title = \"Rent Burden by Transportation Method\",\n            x_label = \"Transportation Method\",\n            y_label = \"Gross Rent as Percentage of Household Income\",\n            fill_colors = c(\"Car\" = \"#66c2a5\", \"Public Transport\" = \"#fc8d62\"))\n\n\n\n\n\n\n\n# T-test to compare means\nt_test_result &lt;- t.test(GRPIP ~ transport_category, data = transport_rent_data)\nprint(\"T-test result:\")\n\n[1] \"T-test result:\"\n\nprint(t_test_result)\n\n\n    Welch Two Sample t-test\n\ndata:  GRPIP by transport_category\nt = -3.4031, df = 225.54, p-value = 0.0007882\nalternative hypothesis: true difference in means between group Car and group Public Transport is not equal to 0\n95 percent confidence interval:\n -9.757693 -2.601332\nsample estimates:\n             mean in group Car mean in group Public Transport \n                      32.89993                       39.07944 \n\n# Visualization: Density plot\nggplot(transport_rent_data, aes(x = GRPIP, fill = transport_category)) +\n  geom_density(alpha = 0.5) +\n  labs(title = \"Distribution of Rent Burden by Transportation Method\",\n       x = \"Gross Rent as Percentage of Household Income\",\n       y = \"Density\") +\n  theme_minimal()\n\n\n\n\n\n\n\n# Calculate mean GRPIP for each category\nmean_grpip &lt;- aggregate(GRPIP ~ transport_category, data = transport_rent_data, mean)\nprint(\"Mean GRPIP by transportation category:\")\n\n[1] \"Mean GRPIP by transportation category:\"\n\nprint(mean_grpip)\n\n  transport_category    GRPIP\n1                Car 32.89993\n2   Public Transport 39.07944\n\n# Additional: Count of users in each category\nuser_counts &lt;- table(transport_rent_data$transport_category)\nprint(\"Number of users in each category:\")\n\n[1] \"Number of users in each category:\"\n\nprint(user_counts)\n\n\n             Car Public Transport \n            5456              214 \n\n\nSummary Statistics:\nCar Users: Mean GRPIP = 32.9%, Median = 26% Public Transport Users: Mean GRPIP = 39.1%, Median = 31%\nBoxplot Analysis (Image 1):\nThe median rent burden for public transport users is higher than for car users. Public transport users show a wider interquartile range, indicating more variability in rent burden. Both groups have outliers, but public transport users have more extreme high outliers.\nDensity Plot Analysis (Image 2):\nThe distribution for car users is more peaked and concentrated around lower GRPIP values. Public transport users have a flatter, more spread-out distribution, with a higher density at higher GRPIP values.\nT-test Results:\nt-statistic: -3.4031 p-value: 0.0007882 (highly significant) 95% confidence interval: [-9.76, -2.60] The test indicates a statistically significant difference in mean GRPIP between car and public transport users.\nMean GRPIP:\nCar: 32.90% Public Transport: 39.08%\nUser Counts:\nCar: 5,456 users Public Transport: 214 users\nKey Findings:\n\nSignificant Difference: There is a statistically significant difference in rent burden between car users and public transport users.\nHigher Burden for Public Transport Users: On average, public transport users spend about 6.2% more of their income on rent compared to car users.\nVariability: Public transport users show more variability in their rent burden, with a wider range of GRPIP values.\nPredominance of Car Users: There’s a much larger number of car users compared to public transport users in the sample.\n\n\n\n\n\nIn this project we extracted The Public Use Microdata Sample (PUMS) Census API (Application Programming Interface) using main_query function. The summary.census function is used to summarize the data. This main_query function acts as an important tool for researchers and others to quickly access data from the U.S. Census in a customizable way to create tibbles for analysis regarding the U.S. population and housing units. The plot function is used to plot the box plot. The data is analyzed to answer the key questions such as 1. What is the overall age and gender distribution of the population? 2. Is there a relationship between household language and economic indicators like rent burden? 3. How does the educational attainment vary across age groups and genders? 4. What are the most common means of transportation to work, and how do they relate to commute times? 5. Is there any relationship between the Mean of Transportation and Rent Burden?\nIn summary, there is no large gap between the gender distribution. The dominance of personal vehicles, the significant proportion of remote workers, and the relatively low usage of public transit are key findings. Addressing the question about the connection between household language and economic indicators, the data suggests that there’s a clear disparity in rent burden across language groups, with English-only households generally facing lower rent burdens. There’s a noticeable jump in median age for doctorate degrees (24), with females having a slightly higher median age than males. While checking the relationship between the mean of transportation and rent burden we came to conclusion that the analysis reveals a strong relationship between transportation method choice and rent burden, with public transport users facing significantly higher housing cost burdens. This insight could be valuable for urban planners, policymakers, and researchers focusing on transportation equity and affordable housing initiatives."
  },
  {
    "objectID": "Project1.html#part-i-obtaining-the-data-from-pums-api",
    "href": "Project1.html#part-i-obtaining-the-data-from-pums-api",
    "title": "ST: 558 Project 1",
    "section": "",
    "text": "Next, we are going to show how URL can interact with the PUMS’ API. Typically we’d start with a more bare URL when building a URL from scratch (more on that later), but I ended choosing this one because it provided a more visually appealing output as an example. After setting up the URL and making a GET, request to PUMS’ API (a request sent to a server asking an API to provide a service/information), we’ll take that raw data, and parse it into JSON. The initial_parse returns a tibble with the column names on the first row, so we extract those names and set them as the column names. Then we drop the first row and print a nice little tibble to get a glimpse of what information the example_url contains (take a look below!). Here we have a small tibble, 6x4, because we used the function head. These are the steps to querying APIs. So in short, we assign a URL, formulate the API request, send it, allow time to handle the response, and process the data.\n\n\n# Sample API call, transformed to tibble\nexample_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\ninitial_response &lt;- GET(url = example_url)\ninitial_parse &lt;- fromJSON(rawToChar(initial_response$content))\ncol_names &lt;- (initial_parse[1,])\ncolnames(initial_parse) &lt;- col_names\ninitial_parse &lt;- initial_parse[-1,]\ninitial_parse &lt;- as_tibble(initial_parse)\nhead(initial_parse)\n\n# A tibble: 6 × 4\n  SEX   PWGTP MAR   SCHL \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 2     6     5     24   \n2 2     23    2     24   \n3 1     23    3     24   \n4 1     80    5     24   \n5 1     16    1     24   \n6 1     107   3     24   \n\n\n\nTo keep things simple and organized, below are all of the variables and their assigned values. Here we created vectors for each variable to reference later on.\n\n\n# Numeric variables\nnum_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")\n\n# Categorical variables\ncat_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n\n# Time variables\ntime_vars &lt;- c(\"JWAP\", \"JWDP\")\n\n# Geography variables\ngeo_vars &lt;- c(\"All\", \"Region\", \"Division\", \"State\")\n\n# Combined variables (numeric categorical, time)\ncombined_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\", \"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\", \"JWAP\", \"JWDP\")\n\n\nNext we’ll dive into all of the functions we made in order to create our main API query. The first one we have is the year_checker function. Our if statement here only allows the function to pass if the year is between 2010 to 2022 (values are inclusive). However, if the year falls outside of the range, a stop function will raise an error message and cease execution of the code.\n\n\n# Year Checker\n# Function to check if entered year is valid\n\nyear_checker &lt;- function(year) {\n  if (year &gt; 2022 | year &lt; 2010) {\n    stop(\"Invalid year value. Please type in a number between 2010 and 2022.\")\n  }\n}\n\n\nOur second function, the num_checker, checks and coerces our assigned numeric and time variables to their respective data types. Due to the parsed JSON data, our data defaulted to a data type of character. Coercing the variables to the desired data type allows for meaning manipulation and analysis. This function contains 1 parameter and takes in 2 vectors, num_vars and time_vars, which is used to determine if the user input is of type num or time then converts it respectively to its desired data type. The function works by looping the column names from initial_parse. Each column name is checked to see if its name matches any from the 2 vectors, num_vars or time_vars. If the column name matches in num_vars, it will be converted to numeric through the use of as.numeric. Similarly with time_vars, it will be converted to a time format through the use of as.NUMERIC. Once the function finishes looping, it will return the modified tibble/dataframe.\n\n\n# Numeric Checker\n# Function to convert columns to desired numeric and time data types\n\nnum_checker &lt;- function(initial_parse) {\n    num_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\")\n    time_vars &lt;- c(\"JWAP\", \"JWDP\")\n    col_names &lt;- colnames(initial_parse) \n      for (name in col_names) {\n         if (name %in% num_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.numeric(initial_parse[[name]])\n            \n         }\n     \n      }\n    return(initial_parse)\n}\n\n# Testing purposes/example\ninitial_parse &lt;- num_checker(initial_parse)\n\n[1] \"PWGTP\"\n\n\n\nCategorical checker works similarly to the numeric checker. This function contains 1 parameter and takes in 1 vector, which is used to determine if the user input is of type factor then converts it respectively to its desired data type.\n\n\n# Categorical checker\n# Function to convert columns to desired factor data types\n\n\ncat_checker &lt;- function(initial_parse) {\n    cat_vars &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n    col_names &lt;- colnames(initial_parse) \n      for (name in col_names) {\n         if (name %in% cat_vars) {\n            print(name)   \n            initial_parse[[name]] &lt;- as.factor(initial_parse[[name]])\n         }  \n         if (name == \"SEX\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(SEX = recode(SEX, \"1\" = \"Male\", \"2\" = \"Female\"))\n      }\n      if (name == \"SCHL\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(SCHL = recode(SCHL, \"0\" = \"N/A (less than 3 years old)\", \"1\" = \"No schooling completed\", \"2\" = \"Nursery school, preschool\", \"3\" = \"Kindergarten\", \"4\" = \"Grade 1\", \"5\" = \"Grade 2\", \"6\" = \"Grade 3\", \"7\" = \"Grade 4\", \"8\" = \"Grade 5\", \"9\" = \"Grade 6\", \"10\" = \"Grade 7\", \"11\" = \"Grade 8\", \"12\" = \"Grade 9\", \"13\" = \"Grade 10\", \"14\" = \"Grade 11\", \"15\" = \"12th grade - no diploma\", \"16\" = \"Regular high school diploma\", \"17\" = \"GED or alternative credential\", \"18\" = \"Some college, but less than 1 year\", \"19\" = \"1 or more years of college credit, no degree\", \"20\" = \"Associate’s degree\", \"21\" = \"Bachelor’s degree\", \"22\" = \"Master’s degree\", \"23\" = \"Professional degree beyond a bachelor’s degree\", \"24\" = \"Doctorate degree\"))\n      }\n      if (name == \"HISPEED\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(HISPEED = recode(HISPEED, \"0\" = \"N/A (GQ/vacant/no paid access to the internet)\", \"1\" = \"Yes\", \"2\" = \"No\"))\n      }\n      if (name == \"HHL\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(HHL = recode(HHL, \"0\" = \"N/A (GQ/vacant\", \"1\" = \"English Only\", \"2\" = \"Spanish\", \"3\" = \"Other Indo-European languages\", \"4\" = \"Asian and Pacific Island languages\", \"5\" = \"Other languages\"))\n      }\n      if (name == \"FER\") {\n        initial_parse &lt;- initial_parse %&gt;% \n          mutate(FER = recode(FER, \"0\" = \"N/A (less than 15 years/greater than 50 years/ male)\", \"1\" = \"Yes\", \"2\" = \"No\"))\n      }\n  \n\n    }\n\n      return(initial_parse)\n}\n\n# Testing purposes/example\ninitial_parse &lt;- cat_checker(initial_parse)\n\n[1] \"SEX\"\n[1] \"SCHL\"\n\n\n\nNext we have the geography checker. This function has 1 parameter and takes in 1 vector. If the provided geography_level is in the geo_vars vector, it will print that the geography level is valid. If not then it will print is not valid.\n\n\n# Geography Checker\n# Function to specify and  check if geography level is correct\n\ngeo_checker &lt;- function(geography_level, geography_subset) {\n  geo_vars &lt;- c(\"All\", \"Region\", \"Division\", \"State\")\n  if (geography_level %in% geo_vars) {\n    print(\"Geography level is valid.\") \n  }\n  else {\n    print(\"Geography level is not valid.\")\n  }\n}\n\n# Testing purposes/example\ngeo_checker(\"State\", \"08\")\n\n[1] \"Geography level is valid.\"\n\n\n\nHere we have a function to query the census. This function contains 4 parameters. First, an empty tibble is initialized in order to store the results; this is important as it holds the multiple tibbles to later bind together. We assign a variable named year_list to take on the function string split for parameter, year, because we want to allow the user to be able to specify multiple years of survey data. String split works here because when inputting multiple years, “2012,2013,2015”, the user needs to input the years all as one string, then strsplit will work to split the different years into a list of year to call each year separately. The for loop at the bottom, (i in year_list[[1]]), loops over the list of years from the user into the query_url, allowing them to make API requests for each given year.\nNext, there are some words that we hard coded into the URL because we needed to return those columns, we chose: “PWGTP”, “GASP”, and “FER”. However, if the user doesn’t know, they could input one of these columns again, producing a duplicate column. To fix this, we have to use grepl, to search for a string within a string then we use gsub to remove the said string. The second gsub is a catch all, removing commas from before/after the string due to user input. This way, even if the user inputs those columns, it would no longer create a duplicate. Then we create an if statement where it does not allow the user to input a geography_subset if they choose “All” by creating a variable named geo_meta and add it onto our query_url below. So to briefly go over our first example, bottom portion of the code is using the given query_url, we send a GET request to formulate the API request, allow time to handle the response, process the data, extract column nam, apply them accordingly, then create tibbles. As mentioned earlier, if user inputs multiple years then the for loop won’t end until the last inputted year, then the bind_rows function will combine all of the tibbles from each year of the user input together.\n\n\n# Function to Query the Census API \n# Created if statements using grepl/gsub to remove duplicate columns\n# Allow users to call multiple years then combining tibbles as the end using bind_rowss\n# Used helper GET here then turned into tibble\n\ncensus_query &lt;- function(year, geography_level, geography_subset, get) {\n    initial_parse_final &lt;- tibble()\n    year_list &lt;- strsplit(year, \",\")\n    url &lt;- \"https://api.census.gov/data/\"\n    if (grepl(\"PWGTP\", get)) {\n      get &lt;- gsub(\"PWGTP|PWGTP,\",'',get)\n      get &lt;- gsub(\"^\\\\,|\\\\,$\",'',get) \n    }\n    if (grepl(\"GASP\", get)) {\n      get &lt;- gsub(\"GASP|GASP,\",'',get)\n      get &lt;- gsub(\"^\\\\,|\\\\,$\",'',get)\n    }\n    if (grepl(\"FER\", get)) {\n      get &lt;- gsub(\"FER|FER,\",'',get)\n      get &lt;- gsub(\"^\\\\,|\\\\,$\",'',get)\n    }\n    geo_meta &lt;- paste0(\"&for=\", geography_level,\":\",geography_subset)\n    if (geography_level == \"All\") {\n      geo_meta &lt;- \"\"\n    }\n    for (i in year_list[[1]]) {\n      query_url &lt;- paste0(url,i,\"/acs/acs1/pums?\",\"get=PWGTP,GASP,FER,\",get,geo_meta)\n      initial_response &lt;- GET(url = query_url)\n      initial_parse &lt;- fromJSON(rawToChar(initial_response$content))\n      col_names &lt;- (initial_parse[1,])\n      colnames(initial_parse) &lt;- col_names\n      initial_parse &lt;- initial_parse[-1,]\n      initial_parse &lt;- as_tibble(initial_parse)\n      initial_parse_final &lt;- bind_rows(initial_parse,initial_parse_final)\n    }\n    return(initial_parse_final)\n}\n\n# Testing purposes/example\ninitial_parse &lt;- census_query(year = \"2011,2014\", \"State\", \"08\", \"AGEP,SEX\")\n\n\nNow we can create our final/main API query. This API query contains 4 parameters (year = “2022”, geography_level = “All”, geography_subset and get = “SEX,AGEP,PWGTP”, with their respective defaults) and takes in vector combined_vars. We create a strsplit for the get results, similarly to what we did for the years in the census_query results. When a user inputs variables, it will check and ensure those column names are valid. If they are then it will print, “Column X entered is valid” and if not then it will tell the user to try again. After that, initial_parse is reassigned and overwritten once it goes through each function (census_query, num_checker, time_checker, cat_checker) and checker (geo_checker, year_checker). Then it will return a final tibble at the end.\n\n\n\n\n# Main API Query Function (combined all of the previous functions)\n# Added SEX, AGEP, PWGTP in the get of the main_query to be returned as default\n# Added combined_vars and for loop to validate and check that user inputted columns are valid\n\nmain_query &lt;- function(year = \"2022\", \n                       geography_level = \"All\", \n                       geography_subset,  \n                       get = \"SEX,AGEP,PWGTP\") { \n    combined_vars &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWMNP\", \"PWGTP\", \"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\", \"JWAP\", \"JWDP\")\n    get_list &lt;- strsplit(get, \",\")\n    for (i in get_list[[1]]) {\n      if (i %in% combined_vars) {\n        cat(\"Column (\",i ,\") entered is valid.\")\n      }\n      else (\n        stop(\"Column (\",i,\") entered is not valid. Try again\")\n            )\n    }\n    initial_parse &lt;- census_query(year, geography_level, geography_subset, get)\n    initial_parse &lt;- num_checker(initial_parse)\n    initial_parse &lt;- cat_checker(initial_parse)\n    geo_checker(geography_level, geography_subset)\n    year_checker(year) \n    \n    # This is for the summary function in Part 2\n    class(initial_parse) &lt;-c(\"census\", class(initial_parse))\n    return(initial_parse)\n} \n\n# Testing purposes/example\ntest &lt;- main_query(\"2018,2015\", \"State\", \"08\", \"FER,JWAP,SEX,SCHL,GASP\")\n\nColumn ( FER ) entered is valid.Column ( JWAP ) entered is valid.Column ( SEX ) entered is valid.Column ( SCHL ) entered is valid.Column ( GASP ) entered is valid.[1] \"PWGTP\"\n[1] \"GASP\"\n[1] \"FER\"\n[1] \"SEX\"\n[1] \"SCHL\"\n[1] \"Geography level is valid.\"\n\n# All variable query\neverything &lt;- main_query(\"2022\", \"State\", \"08\", \"AGEP,GASP,GRPIP,JWMNP,PWGTP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX,JWAP,JWDP\")\n\nColumn ( AGEP ) entered is valid.Column ( GASP ) entered is valid.Column ( GRPIP ) entered is valid.Column ( JWMNP ) entered is valid.Column ( PWGTP ) entered is valid.Column ( FER ) entered is valid.Column ( HHL ) entered is valid.Column ( HISPEED ) entered is valid.Column ( JWTRNS ) entered is valid.Column ( SCH ) entered is valid.Column ( SCHL ) entered is valid.Column ( SEX ) entered is valid.Column ( JWAP ) entered is valid.Column ( JWDP ) entered is valid.[1] \"PWGTP\"\n[1] \"GASP\"\n[1] \"AGEP\"\n[1] \"GRPIP\"\n[1] \"JWMNP\"\n[1] \"FER\"\n[1] \"HHL\"\n[1] \"HISPEED\"\n[1] \"JWTRNS\"\n[1] \"SCH\"\n[1] \"SCHL\"\n[1] \"SEX\"\n[1] \"Geography level is valid.\"\n\nprint(everything)\n\n# A tibble: 59,841 × 15\n   PWGTP  GASP FER       AGEP GRPIP JWMNP HHL   HISPEED JWTRNS SCH   SCHL  SEX  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt;   &lt;fct&gt;  &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;\n 1    70     3 No          18     0     0 N/A … N/A (G… 11     2     Some… Fema…\n 2    41     3 N/A (le…    35     0     0 N/A … N/A (G… 0      1     Grad… Male \n 3    35     3 N/A (le…    40     0     0 N/A … N/A (G… 0      1     Grad… Male \n 4    30     3 No          20     0     0 N/A … N/A (G… 0      2     1 or… Fema…\n 5     4     3 N/A (le…    14     0     0 N/A … N/A (G… 0      2     Grad… Male \n 6    75     3 No          28     0     0 N/A … N/A (G… 0      1     Regu… Fema…\n 7    22     3 N/A (le…    47     0     0 N/A … N/A (G… 0      1     Regu… Male \n 8    36     3 N/A (le…    28     0     0 N/A … N/A (G… 0      1     Regu… Male \n 9    59     3 N/A (le…    77     0     0 N/A … N/A (G… 0      1     Regu… Fema…\n10    11     3 N/A (le…    20     0     2 N/A … N/A (G… 10     1     Some… Male \n# ℹ 59,831 more rows\n# ℹ 3 more variables: JWAP &lt;chr&gt;, JWDP &lt;chr&gt;, state &lt;chr&gt;\n\n\n\nThe API function, main_query, interacts, retrieves, and processes raw data from the U.S. Census API, and allows us to query, structure, and validate data, into a tibble based on user input. With that, we will move onto creating the summary and plot functions, hoping to research and analyze some interesting data that we extract from the API function."
  },
  {
    "objectID": "Project1.html#part-ii-summarizing-the-data-and-plots",
    "href": "Project1.html#part-ii-summarizing-the-data-and-plots",
    "title": "ST: 558 Project 1",
    "section": "",
    "text": "In this section we have created 2 functions “Summary” function takes the data from tibble and generate summary statistics (mean and standard deviation) for all numeric variables and counts for all categorical variables from the data frame. This function takes three arguments - class census, numeric variables to generate summary statistics and categorical variables. The second function is a plot function, where we generate the box plot.\n\n\nsummary.census &lt;- function(object, numeric_vars = NULL, categorical_vars = NULL) {\n  \n  #convert JWAP and JWDP into numeric variables\n  object$JWAP &lt;- as.numeric(object$JWAP)\n  object$JWDP &lt;- as.numeric(object$JWDP)\n  \n  # If no variables specified, get all appropriate variables\n  if (is.null(numeric_vars)) {\n    numeric_vars &lt;- c(names(object)[sapply(object, is.numeric)], \"JWAP\", \"JWDP\")\n    numeric_vars &lt;- setdiff(numeric_vars, \"PWGTP\")  # Exclude weight variable\n  }\n  \n  if (is.null(categorical_vars)) {\n    categorical_vars &lt;- names(object)[sapply(object, function(x) \n      is.character(x) || is.factor(x))]\n  }\n  \n  # Ensure JWAP and JWDP are in numeric_vars and not in categorical_vars\n  numeric_vars &lt;- union(numeric_vars, c(\"JWAP\", \"JWDP\"))\n  categorical_vars &lt;- setdiff(categorical_vars, c(\"JWAP\", \"JWDP\"))\n  \n  # Initialize results list\n  results &lt;- list()\n  \n  # Define labels for all variables\n  variable_labels &lt;- list(\n    AGEP = \"Age\",\n    JWMNP = \"Travel time to work\",\n    GRPIP = \"Gross rent as a percentage of household income\",\n    GASP = \"Gasoline cost (monthly)\",\n    FER = \"Gave birth to child within the past 12 months\",\n    SEX = \"Sex\",\n    SCH = \"School enrollment\",\n    SCHL = \"Educational attainment\",\n    HHL = \"Household language\",\n    HISPEED = \"High speed internet\",\n    JWTRNS = \"Means of transportation to work\",\n    JWAP = \"Time of arrival at work\",\n    JWDP = \"Time of departure for work\"\n  )\n  \n  # Calculate weighted means and standard deviations for numeric variables\n  if (length(numeric_vars) &gt; 0) {\n    numeric_summary &lt;- list()\n    \n    for (var in numeric_vars) {\n      # Get the variable and weights\n      x &lt;- object[[var]]\n      w &lt;- object[[\"PWGTP\"]]\n      \n      # Remove NA and infinite values\n      valid &lt;- !is.na(x) & !is.infinite(x) & !is.na(w) & !is.infinite(w)\n      x &lt;- x[valid]\n      w &lt;- w[valid]\n      \n      # Calculate weighted mean\n      weighted_mean &lt;- sum(x * w) / sum(w)\n      \n      # Calculate weighted standard deviation\n      weighted_sd &lt;- sqrt(sum(x^2 * w) / sum(w) - weighted_mean^2)\n      \n      # Get label for the variable\n      label &lt;- if (var %in% names(variable_labels)) variable_labels[[var]] else var\n      \n      # Store results\n      numeric_summary[[label]] &lt;- list(\n        mean = weighted_mean,\n        sd = weighted_sd\n      )\n    }\n    \n    results[[\"numeric_summary\"]] &lt;- numeric_summary\n  }\n  \n  # Calculate counts for categorical variables\n  if (length(categorical_vars) &gt; 0) {\n    categorical_summary &lt;- list()\n    \n    # Define mappings for categorical variables\n    category_mappings &lt;- list(\n      FER = c(\"0\" = \"N/A\", \"1\" = \"Yes\", \"2\" = \"No\"),\n      SEX = c(\"1\" = \"Male\", \"2\" = \"Female\"),\n      SCHL = c(\"1\" = \"No schooling completed\",\n               \"2\" = \"Nursery school, preschool\",\n               \"3\" = \"Kindergarten\",\n               \"4\" = \"Grade 1\",\n               \"5\" = \"Grade 2\",\n               \"6\" = \"Grade 3\",\n               \"7\" = \"Grade 4\",\n               \"8\" = \"Grade 5\",\n               \"9\" = \"Grade 6\",\n               \"10\" = \"Grade 7\",\n               \"11\" = \"Grade 8\",\n               \"12\" = \"Grade 9\",\n               \"13\" = \"Grade 10\",\n               \"14\" = \"Grade 11\",\n               \"15\" = \"12th grade - no diploma\",\n               \"16\" = \"Regular high school diploma\",\n               \"17\" = \"GED or alternative credential\",\n               \"18\" = \"Some college, but less than 1 year\",\n               \"19\" = \"1 or more years of college credit, no degree\",\n               \"20\" = \"Associate's degree\",\n               \"21\" = \"Bachelor's degree\",\n               \"22\" = \"Master's degree\",\n               \"23\" = \"Professional degree beyond a bachelor's degree\",\n               \"24\" = \"Doctorate degree\"),\n      HHL = c(\"0\" = \"N/A (GQ/vacant)\",\n              \"1\" = \"English Only\",\n              \"2\" = \"Spanish\",\n              \"3\" = \"Other Indo-European languages\",\n              \"4\" = \"Asian and Pacific Island languages\",\n              \"5\" = \"Other Language\"),\n      HISPEED = c(\"0\" = \"N/A (GQ/vacant/no paid access to the internet)\",\n                  \"1\" =  \"Yes\",\n                  \"2\" = \"No\"),\n      \n      SCH = c(\"0\" = \"N/A (less than 3 years old)\",\n              \"1\" = \"No, has not attended in the last 3 months\",\n              \"2\" = \"Yes, public school or public college\",\n              \"3\" = \"Yes, private school or college or home school\"))\n      \n    \n    for (var in categorical_vars) {\n      # Get counts\n      counts &lt;- table(object[[var]])\n      \n      # Apply mapping if available\n      \n       # Special handling for SEX variable\n      if (var == \"SEX\") {\n        counts_to_use &lt;- counts\n        names(counts_to_use) &lt;- levels(object[[var]])  # Preserve original labels\n      }else   if (var == \"JWTRNS\") {\n      # Special handling for JWTRNS\n      jwtrns_mapping &lt;- c(\n        \"0\" = \"N/A\",\n        \"1\" = \"Car, truck, or van\",\n        \"2\" = \"Bus\",\n        \"3\" = \"Subway or elevated rail\",\n        \"4\" = \"Long-distance train or commuter rail\",\n        \"5\" = \"Light rail, streetcar, or trolley\",\n        \"6\" = \"Ferryboat\",\n        \"7\" = \"Taxicab\",\n        \"8\" = \"Motorcycle\",\n        \"9\" = \"Bicycle\",\n        \"10\" = \"Walked\",\n        \"11\" = \"Worked from home\",\n        \"12\" = \"Other method\"\n      )\n      counts_to_use &lt;- counts\n      names(counts_to_use) &lt;- jwtrns_mapping[names(counts)]\n      } else if (var %in% names(category_mappings)) {\n        mapped_counts &lt;- counts\n        names(mapped_counts) &lt;- category_mappings[[var]][names(counts)]\n        counts_to_use &lt;- mapped_counts\n      } else {\n        counts_to_use &lt;- counts\n      }\n      \n      # Get label for the variable\n      label &lt;- if (var %in% names(variable_labels)) variable_labels[[var]] else var\n      \n      # Store results with label\n      categorical_summary[[label]] &lt;- counts_to_use\n    }\n    \n    results[[\"categorical_summary\"]] &lt;- categorical_summary\n  }\n  \n  return(results)\n}\n\nNow Let’s test our summary function. This will give us the weighted means and standard deviations for numeric variables and counts for categorical variables\n\n# Using default behavior (all variables)\nresults1 &lt;- summary.census(everything)\nprint(results1)\n\n$numeric_summary\n$numeric_summary$`Gasoline cost (monthly)`\n$numeric_summary$`Gasoline cost (monthly)`$mean\n[1] 65.96931\n\n$numeric_summary$`Gasoline cost (monthly)`$sd\n[1] 145.7646\n\n\n$numeric_summary$Age\n$numeric_summary$Age$mean\n[1] 38.80219\n\n$numeric_summary$Age$sd\n[1] 22.42793\n\n\n$numeric_summary$`Gross rent as a percentage of household income`\n$numeric_summary$`Gross rent as a percentage of household income`$mean\n[1] 10.71139\n\n$numeric_summary$`Gross rent as a percentage of household income`$sd\n[1] 22.36287\n\n\n$numeric_summary$`Travel time to work`\n$numeric_summary$`Travel time to work`$mean\n[1] 10.6618\n\n$numeric_summary$`Travel time to work`$sd\n[1] 18.26052\n\n\n$numeric_summary$`Time of arrival at work`\n$numeric_summary$`Time of arrival at work`$mean\n[1] 42.47839\n\n$numeric_summary$`Time of arrival at work`$sd\n[1] 55.53998\n\n\n$numeric_summary$`Time of departure for work`\n$numeric_summary$`Time of departure for work`$mean\n[1] 22.43893\n\n$numeric_summary$`Time of departure for work`$sd\n[1] 31.50714\n\n\n\n$categorical_summary\n$categorical_summary$`Gave birth to child within the past 12 months`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n46345   655 12841 \n\n$categorical_summary$`Household language`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 2790 46143  6558  2226  1591   533 \n\n$categorical_summary$`High speed internet`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 5405 47042  7394 \n\n$categorical_summary$`Means of transportation to work`\n                                 N/A                   Car, truck, or van \n                               29658                                21488 \n                              Walked                     Worked from home \n                                 816                                 6791 \n                        Other method                                  Bus \n                                 272                                  279 \n             Subway or elevated rail Long-distance train or commuter rail \n                                  13                                   15 \n   Light rail, streetcar, or trolley                            Ferryboat \n                                 104                                    6 \n                             Taxicab                           Motorcycle \n                                  17                                   50 \n                             Bicycle \n                                 332 \n\n$categorical_summary$`School enrollment`\n                  N/A (less than 3 years old) \n                                         1592 \n    No, has not attended in the last 3 months \n                                        45041 \n         Yes, public school or public college \n                                        11146 \nYes, private school or college or home school \n                                         2062 \n\n$categorical_summary$`Educational attainment`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 1592  1502   777   941   952  1111  1342   790  8407  1842  3275  6427   773 \n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 3761 13278  5970  1284  1031   665   576   648   682   710   717   788 \n\n$categorical_summary$Sex\n  Male Female \n 29940  29901 \n\n$categorical_summary$state\n\n   08 \n59841 \n\n\nWe can use specific variables and check if we can generate the summary for examples we can select few numeric variables and few categorical variables as follows\n\n# Specifying specific variables\nresults &lt;- summary.census(everything, \n                  numeric_vars = c(\"AGEP\", \"GRPIP\"),\n                  categorical_vars = c(\"SEX\", \"FER\"))\n\nprint(results)\n\n$numeric_summary\n$numeric_summary$Age\n$numeric_summary$Age$mean\n[1] 38.80219\n\n$numeric_summary$Age$sd\n[1] 22.42793\n\n\n$numeric_summary$`Gross rent as a percentage of household income`\n$numeric_summary$`Gross rent as a percentage of household income`$mean\n[1] 10.71139\n\n$numeric_summary$`Gross rent as a percentage of household income`$sd\n[1] 22.36287\n\n\n$numeric_summary$`Time of arrival at work`\n$numeric_summary$`Time of arrival at work`$mean\n[1] 42.47839\n\n$numeric_summary$`Time of arrival at work`$sd\n[1] 55.53998\n\n\n$numeric_summary$`Time of departure for work`\n$numeric_summary$`Time of departure for work`$mean\n[1] 22.43893\n\n$numeric_summary$`Time of departure for work`$sd\n[1] 31.50714\n\n\n\n$categorical_summary\n$categorical_summary$Sex\n  Male Female \n 29940  29901 \n\n$categorical_summary$`Gave birth to child within the past 12 months`\n &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n46345   655 12841 \n\n\n\n\n\n\nplot.census &lt;- function(x, cat_var, num_var, \n                        title = NULL, \n                        x_label = NULL, \n                        y_label = NULL, \n                        fill_colors = c(\"#1f77b4\", \"#ff7f0e\"),\n                        ...) {\n  # Check if the object is of class \"census\"\n  if (!inherits(x, \"census\")) {\n    stop(\"This function only works for objects of class 'census'\")\n  }\n  \n  # Check if cat_var and num_var are provided\n  if (missing(cat_var) || missing(num_var)) {\n    stop(\"Both cat_var and num_var must be specified\")\n  }\n  \n  # Check if cat_var and num_var exist in the data\n  if (!cat_var %in% names(x)) {\n    stop(paste(\"Categorical variable\", cat_var, \"not found in the data\"))\n  }\n  if (!num_var %in% names(x)) {\n    stop(paste(\"Numeric variable\", num_var, \"not found in the data\"))\n  }\n  \n  # Check if cat_var is categorical (factor or character)\n  if (!is.factor(x[[cat_var]]) && !is.character(x[[cat_var]])) {\n    stop(paste(cat_var, \"must be a categorical variable (factor or character)\"))\n  }\n  \n  # Check if num_var is numeric\n  if (!is.numeric(x[[num_var]])) {\n    stop(paste(num_var, \"must be a numeric variable\"))\n  }\n  \n  # Set default labels if not provided\n  if (is.null(title)) {\n    title &lt;- paste(\"Weighted Boxplot of\", num_var, \"by\", cat_var)\n  }\n  if (is.null(x_label)) {\n    x_label &lt;- cat_var\n  }\n  if (is.null(y_label)) {\n    y_label &lt;- num_var\n  }\n  \n  # Create the plot\n  p &lt;- ggplot(x, aes(x = .data[[cat_var]], y = .data[[num_var]], weight = PWGTP, fill = .data[[cat_var]])) +\n    geom_boxplot() +\n    labs(title = title, x = x_label, y = y_label) +\n    scale_fill_manual(values = fill_colors) +\n    theme_minimal() +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1),\n          legend.position = \"none\")  # Remove legend as it's redundant with x-axis labels\n  \n  # Print the plot\n  print(p)\n  \n  # Return the plot object invisibly\n  invisible(p)\n}\n\nLet’s test the plot function\n\n# Age distribution by sex\n\nplot.census(everything, \n            cat_var = \"SEX\", \n            num_var = \"AGEP\",\n            title = \"Age Distribution by Sex\",\n            x_label = \"Sex\",\n            y_label = \"Age\",\n            fill_colors = c(\"#FFA07A\", \"#20B2AA\"))\n\n\n\n\n\n\n\n# Travel time to work by sex\nplot.census(everything, \n            cat_var = \"SEX\", \n            num_var = \"JWMNP\",\n            title = \"Travel Time to Work by Sex\",\n            x_label = \"Sex\",\n            y_label = \"Travel Time (minutes)\",\n            fill_colors = c(\"#4E79A7\", \"#F28E2B\"))\n\n\n\n\n\n\n\n#Gross rent as percentage of income by household language\n\n# Create a color palette for the number of language categories\nnum_languages &lt;- length(unique(everything$HHL))\ncolor_palette &lt;- colorRampPalette(c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"))(num_languages)\n\n# Create the plot\nrent_language_plot &lt;- plot.census(everything, \n                                  cat_var = \"HHL\", \n                                  num_var = \"GRPIP\",\n                                  title = \"Gross Rent as Percentage of Household Income by Household    \n                                           Language\",\n                                  x_label = \"Household Language\",\n                                  y_label = \"Gross Rent as Percentage of Income\",\n                                  fill_colors = color_palette)"
  },
  {
    "objectID": "Project1.html#understanding-the-data-and-interpresting-it-using-statistics",
    "href": "Project1.html#understanding-the-data-and-interpresting-it-using-statistics",
    "title": "ST: 558 Project 1",
    "section": "",
    "text": "Now we are all set! We can extract the data using main_query function and summaries it by summary.census function also we can create box plots using the plot function. Let’s understand the relationship between different variables and interpret the data using our summary and plot functions.\nFor example we would like to get the answers of following questions #### What is the overall age and gender distribution of the population?\n\n# Get summary statistics\nsummary_stats &lt;- summary.census(everything)\nprint(summary_stats$numeric_summary$Age)\n\n$mean\n[1] 38.80219\n\n$sd\n[1] 22.42793\n\nprint(summary_stats$categorical_summary$Sex)\n\n  Male Female \n 29940  29901 \n\n# Create an age distribution plot by gender\nage_gender_plot &lt;- plot.census(everything, \n                               cat_var = \"SEX\", \n                               num_var = \"AGEP\",\n                               title = \"Age Distribution by Gender\",\n                               x_label = \"Gender\",\n                               y_label = \"Age\",\n                               fill_colors = c(\"#FF9999\", \"#66B2FF\"))\n\n\n\n\n\n\n\n\nThe summary statistics for age show:\nMean age: 38.80 years Standard deviation: 22.43 years\nThis indicates that:\nThe average age of the population is about 39 years old. There’s a considerable spread in ages, with a standard deviation of about 22 years. This suggests a diverse population with a mix of younger and older individuals.\nGender Distribution Male = 29,940 (50.03%) Female = 29,901 (49.97%)\nWhich shows not much a difference in gender distribution\n\n\n\n# Create a plot of educational attainment by age, colored by gender\n\nggplot(everything, aes(x = SCHL, y = AGEP, fill = SEX)) +\n  geom_boxplot() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  labs(x = \"Educational Attainment\", y = \"Age\", fill = \"Sex\")\n\n\n\n\n\n\n\n# Create a contingency table of education by gender\ntable(everything$SCHL, everything$SEX)\n\n                                                \n                                                 Male Female\n  N/A (less than 3 years old)                     830    762\n  No schooling completed                          730    772\n  Grade 7                                         414    363\n  Grade 8                                         483    458\n  Grade 9                                         504    448\n  Grade 10                                        587    524\n  Grade 11                                        763    579\n  12th grade - no diploma                         444    346\n  Regular high school diploma                    4335   4072\n  GED or alternative credential                  1118    724\n  Some college, but less than 1 year             1585   1690\n  1 or more years of college credit, no degree   3288   3139\n  Nursery school, preschool                       392    381\n  Associate’s degree                             1729   2032\n  Bachelor’s degree                              6345   6933\n  Master’s degree                                2679   3291\n  Professional degree beyond a bachelor’s degree  696    588\n  Doctorate degree                                558    473\n  Kindergarten                                    353    312\n  Grade 1                                         311    265\n  Grade 2                                         304    344\n  Grade 3                                         354    328\n  Grade 4                                         347    363\n  Grade 5                                         411    306\n  Grade 6                                         380    408\n\n\nThis analysis gives us a detailed picture of educational attainment patterns across age groups and genders in your population. It highlights the progress made in educational equality, particularly in higher education, while also pointing out areas where disparities still exist.\nFrom the contingency table we can compare the two groups (Male vs Female) The most common education level for both genders is “21” (Bachelor’s degree), followed by “16” (Regular high school diploma). Women tend to outnumber men in Associate’s degrees (20) and Bachelor’s degrees (21). Men slightly outnumber women in Professional degrees beyond a bachelor’s degree (23).\nFrom the box plot we observe following things\nThere’s a wide range of ages for most education levels, indicating lifelong learning or varied educational paths. The median age generally increases with higher levels of educational attainment. Lower education levels (0-9) show a wide age range, possibly indicating both young individuals still in school and older individuals with limited formal education. Higher education levels (16-24) show higher median ages, as expected. There’s a noticeable jump in median age for doctorate degrees (24), with females having a slightly higher median age than males.\n\n\n\n\n# Get summary of transportation methods\nsummary_stats &lt;- summary.census(everything)\nprint(summary_stats$categorical_summary$`Means of transportation to work`)\n\n                                 N/A                   Car, truck, or van \n                               29658                                21488 \n                              Walked                     Worked from home \n                                 816                                 6791 \n                        Other method                                  Bus \n                                 272                                  279 \n             Subway or elevated rail Long-distance train or commuter rail \n                                  13                                   15 \n   Light rail, streetcar, or trolley                            Ferryboat \n                                 104                                    6 \n                             Taxicab                           Motorcycle \n                                  17                                   50 \n                             Bicycle \n                                 332 \n\n# Create a plot of commute times by transportation method\nplot.census(everything, \n                            cat_var = \"JWTRNS\", \n                            num_var = \"JWMNP\",\n                            title = \"Commute Times by Transportation Method\",\n                            x_label = \"Transportation Method\",\n                            y_label = \"Commute Time (minutes)\",\n                            fill_colors = colorRampPalette(c(\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\", \"#ffd92f\"))(length(levels(everything$JWTRNS))))\n\n\n\n\n\n\n\n\nThis analysis gives us a clear picture of the transportation landscape in your population. The dominance of personal vehicles, the significant proportion of remote workers, and the relatively low usage of public transit are key findings that have important implications for urban planning, environmental policies, and quality of life in the area.\nNon-commuters or Unspecified: The largest category is “N/A” (49.6%), which likely includes non-workers, remote workers, or those with unspecified commute methods.\nVehicle Dominance: Among those who commute, personal vehicles (car, truck, or van) are overwhelmingly the most common method, used by 36.0% of the total population and 70.9% of specified commuters. Remote Work Trend: A significant portion (11.4%) work from home, reflecting modern work trends and potentially impacting traditional commute patterns.\nActive Transportation: Walking (1.4%) and cycling (0.6%) combined account for 2% of commuters, representing a small but notable group using active transportation.\nPublic Transit: All forms of public transit (bus, light rail, subway, train) combined account for only about 0.7% of commuters, suggesting limited public transit infrastructure or usage.\nAlternative Methods: Motorcycles, taxicabs, and ferryboats are used by a very small fraction of commuters, likely reflecting niche transportation needs or preferences.\n\n\n\n\n# Create a plot of rent burden by household language\n\nplot.census(everything, \n                                  cat_var = \"HHL\", \n                                  num_var = \"GRPIP\",\n                                  title = \"Rent Burden by Household Language\",\n                                  x_label = \"Household Language\",\n                                  y_label = \"Gross Rent as Percentage of Household Income\",\n                                  fill_colors = colorRampPalette(c(\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\"))(length(levels(everything$HHL))))\n\n\n\n\n\n\n\n\nThis analysis provides insights into the relationship between household language and rent burden, addressing the question about the connection between household language and economic indicators. The data suggests that there are indeed significant differences in economic stress related to housing costs across different language groups.\n1. Language Disparities: There’s a clear disparity in rent burden across language groups, with English-only households generally facing lower rent burdens.\n2. Vulnerable Groups: Spanish-speaking households and those speaking “Other Languages” appear to face the highest rent burdens, suggesting greater economic vulnerability.\n3.Variability Within Groups: All language groups show significant variability in rent burden, indicating that factors beyond language (such as income, location, or occupation) play important roles.\n4. Outlines: All groups have outliers with extremely high rent burdens (over 75% of income), but these are more prevalent in non-English speaking households.\n5. Economic Integration: The overlap in distributions suggests that while there are trends, language alone doesn’t determine economic status or rent burden.\n\n\n\n\n# Reclassify transportation categories\neverything$transport_category &lt;- case_when(\n  everything$JWTRNS == \"1\" ~ \"Car\",\n  everything$JWTRNS %in% c(\"2\", \"3\", \"4\", \"5\", \"7\") ~ \"Public Transport\",\n  TRUE ~ \"Other\"\n)\n\n# Filter for car and public transport users with non-zero GRPIP\ntransport_rent_data &lt;- everything[everything$transport_category %in% c(\"Car\", \"Public Transport\") & everything$GRPIP &gt; 0, ]\n\n# Ensure transport_category is a factor\ntransport_rent_data$transport_category &lt;- factor(transport_rent_data$transport_category)\n\n# Summary statistics\ncar_summary &lt;- summary(transport_rent_data$GRPIP[transport_rent_data$transport_category == \"Car\"])\npt_summary &lt;- summary(transport_rent_data$GRPIP[transport_rent_data$transport_category == \"Public Transport\"])\n\nprint(\"Summary for Car Users:\")\n\n[1] \"Summary for Car Users:\"\n\nprint(car_summary)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    1.0    18.0    26.0    32.9    39.0   101.0 \n\nprint(\"Summary for Public Transport Users:\")\n\n[1] \"Summary for Public Transport Users:\"\n\nprint(pt_summary)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00   21.00   31.00   39.08   50.00  101.00 \n\n# Visualization: Boxplot\n\nplot.census(transport_rent_data, \n            cat_var = \"transport_category\", \n            num_var = \"GRPIP\",\n            title = \"Rent Burden by Transportation Method\",\n            x_label = \"Transportation Method\",\n            y_label = \"Gross Rent as Percentage of Household Income\",\n            fill_colors = c(\"Car\" = \"#66c2a5\", \"Public Transport\" = \"#fc8d62\"))\n\n\n\n\n\n\n\n# T-test to compare means\nt_test_result &lt;- t.test(GRPIP ~ transport_category, data = transport_rent_data)\nprint(\"T-test result:\")\n\n[1] \"T-test result:\"\n\nprint(t_test_result)\n\n\n    Welch Two Sample t-test\n\ndata:  GRPIP by transport_category\nt = -3.4031, df = 225.54, p-value = 0.0007882\nalternative hypothesis: true difference in means between group Car and group Public Transport is not equal to 0\n95 percent confidence interval:\n -9.757693 -2.601332\nsample estimates:\n             mean in group Car mean in group Public Transport \n                      32.89993                       39.07944 \n\n# Visualization: Density plot\nggplot(transport_rent_data, aes(x = GRPIP, fill = transport_category)) +\n  geom_density(alpha = 0.5) +\n  labs(title = \"Distribution of Rent Burden by Transportation Method\",\n       x = \"Gross Rent as Percentage of Household Income\",\n       y = \"Density\") +\n  theme_minimal()\n\n\n\n\n\n\n\n# Calculate mean GRPIP for each category\nmean_grpip &lt;- aggregate(GRPIP ~ transport_category, data = transport_rent_data, mean)\nprint(\"Mean GRPIP by transportation category:\")\n\n[1] \"Mean GRPIP by transportation category:\"\n\nprint(mean_grpip)\n\n  transport_category    GRPIP\n1                Car 32.89993\n2   Public Transport 39.07944\n\n# Additional: Count of users in each category\nuser_counts &lt;- table(transport_rent_data$transport_category)\nprint(\"Number of users in each category:\")\n\n[1] \"Number of users in each category:\"\n\nprint(user_counts)\n\n\n             Car Public Transport \n            5456              214 \n\n\nSummary Statistics:\nCar Users: Mean GRPIP = 32.9%, Median = 26% Public Transport Users: Mean GRPIP = 39.1%, Median = 31%\nBoxplot Analysis (Image 1):\nThe median rent burden for public transport users is higher than for car users. Public transport users show a wider interquartile range, indicating more variability in rent burden. Both groups have outliers, but public transport users have more extreme high outliers.\nDensity Plot Analysis (Image 2):\nThe distribution for car users is more peaked and concentrated around lower GRPIP values. Public transport users have a flatter, more spread-out distribution, with a higher density at higher GRPIP values.\nT-test Results:\nt-statistic: -3.4031 p-value: 0.0007882 (highly significant) 95% confidence interval: [-9.76, -2.60] The test indicates a statistically significant difference in mean GRPIP between car and public transport users.\nMean GRPIP:\nCar: 32.90% Public Transport: 39.08%\nUser Counts:\nCar: 5,456 users Public Transport: 214 users\nKey Findings:\n\nSignificant Difference: There is a statistically significant difference in rent burden between car users and public transport users.\nHigher Burden for Public Transport Users: On average, public transport users spend about 6.2% more of their income on rent compared to car users.\nVariability: Public transport users show more variability in their rent burden, with a wider range of GRPIP values.\nPredominance of Car Users: There’s a much larger number of car users compared to public transport users in the sample."
  },
  {
    "objectID": "Project1.html#summary-and-conclusion",
    "href": "Project1.html#summary-and-conclusion",
    "title": "ST: 558 Project 1",
    "section": "",
    "text": "In this project we extracted The Public Use Microdata Sample (PUMS) Census API (Application Programming Interface) using main_query function. The summary.census function is used to summarize the data. This main_query function acts as an important tool for researchers and others to quickly access data from the U.S. Census in a customizable way to create tibbles for analysis regarding the U.S. population and housing units. The plot function is used to plot the box plot. The data is analyzed to answer the key questions such as 1. What is the overall age and gender distribution of the population? 2. Is there a relationship between household language and economic indicators like rent burden? 3. How does the educational attainment vary across age groups and genders? 4. What are the most common means of transportation to work, and how do they relate to commute times? 5. Is there any relationship between the Mean of Transportation and Rent Burden?\nIn summary, there is no large gap between the gender distribution. The dominance of personal vehicles, the significant proportion of remote workers, and the relatively low usage of public transit are key findings. Addressing the question about the connection between household language and economic indicators, the data suggests that there’s a clear disparity in rent burden across language groups, with English-only households generally facing lower rent burdens. There’s a noticeable jump in median age for doctorate degrees (24), with females having a slightly higher median age than males. While checking the relationship between the mean of transportation and rent burden we came to conclusion that the analysis reveals a strong relationship between transportation method choice and rent burden, with public transport users facing significantly higher housing cost burdens. This insight could be valuable for urban planners, policymakers, and researchers focusing on transportation equity and affordable housing initiatives."
  }
]